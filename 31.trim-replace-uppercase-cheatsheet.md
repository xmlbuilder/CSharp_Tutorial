
# ✂️ Trim / 🔁 Replace / 🔠 ToUpper — C#, Java, C++ 비교 치트시트

> C# 예제를 기준으로 **Java**와 **C++**에서 같은 기능을 어떻게 구현/사용하는지 정리했습니다.  
> 유니코드/문화권, 성능, 불변성(immutability) 차이까지 핵심 포인트를 담았습니다.

---

## 0) 한눈에 비교

| 기능 | C# | Java | C++(표준) |
|---|---|---|---|
| Trim(양끝 공백) | `Trim()` / `TrimStart()` / `TrimEnd()` / `Trim(params char[])` | `trim()`(ASCII) / `strip()`(JDK 11+, 유니코드) / `stripLeading()` / `stripTrailing()` | 표준 없음 → 직접 구현 (예시 제공) |
| Replace(리터럴) | `Replace(old, new)` (char 또는 string) | `replace(old, new)` (char 또는 CharSequence) | `find` + `replace` 루프 (예시 제공) |
| Replace(정규식) | `Regex.Replace(...)` | `replaceAll(regex, repl)` / `replaceFirst(...)` | `<regex>` 가능(무거움). 보통 리터럴 치환 루프 권장 |
| ToUpper/ToLower | `ToUpper([CultureInfo])` / `ToLower([CultureInfo])` | `toUpperCase([Locale])` / `toLowerCase([Locale])` | `std::transform` + `std::toupper/tolower` (ASCII 주의) |
| Insert/Remove | `Insert(index, value)` / `Remove(start, count)` | `StringBuilder.insert/replace/delete` 또는 `substring` 결합 | `std::string::insert/erase/replace` |
| 불변성 | `string` 불변 | `String` 불변 (`StringBuilder` 가변) | `std::string` 가변 |

> **유니코드 주의**: 대소문자/공백 인식은 문화권/표준 라이브러리에 따라 다릅니다. 정밀 처리는 **ICU/Boost.Locale** 권장.

---

## 1) C# 예제 (요청 코드 기반)

```csharp
var target = " non-whitespace characters ";
Console.WriteLine($"[{target.Trim()}]");           // [non-whitespace characters]
Console.WriteLine($"[{target.TrimStart()}]");      // [non-whitespace characters ]
Console.WriteLine($"[{target.TrimEnd()}]");        // [ non-whitespace characters]

string q = "{(Hi*";
Console.WriteLine(q.TrimStart('{'));               // "(Hi*"
Console.WriteLine(q.TrimEnd('*'));                 // "{(Hi"

target = "01234ABC567";
Console.WriteLine(target.Remove(5, 3));            // 01234567

target = "012345";
Console.WriteLine(target.Insert(2, "abc"));        // 01abc2345

target = "I hope you could come with us";
Console.WriteLine(target.Replace("hope", "wish")); // I wish you could come with us
Console.WriteLine(target.ToUpper());               // I HOPE YOU COULD COME WITH US
```

---

## 2) Java로 대응

```java
import java.util.Locale;

public class Demo {
  public static void main(String[] args) {
    String target = " non-whitespace characters ";
    System.out.println("[" + target.trim() + "]");               // ASCII만 [non-whitespace characters]
    System.out.println("[" + target.strip() + "]");              // JDK 11+, 유니코드 공백 [non-whitespace characters]
    System.out.println("[" + target.stripLeading() + "]");       // leading [non-whitespace characters ]
    System.out.println("[" + target.stripTrailing() + "]");      // trailing [ non-whitespace characters]

    String q = "{(Hi*";
    System.out.println(q.replaceAll("^\\{+", ""));               // TrimStart('{') 유사(정규식) -> "(Hi*"
    System.out.println(q.replaceAll("\\*+$", ""));               // TrimEnd('*') 유사(정규식) -> "{(Hi"

    String s = "01234ABC567";
    System.out.println(s.substring(0,5) + s.substring(8));       // Remove(5,3)

    String t = "012345";
    System.out.println(new StringBuilder(t).insert(2, "abc"));   // Insert

    String text = "I hope you could come with us";
    System.out.println(text.replace("hope", "wish"));            // 리터럴 치환
    System.out.println(text.toUpperCase(Locale.ROOT));           // 대소문자
  }
}
```

> `String.trim()`은 **ASCII 공백**만 제거합니다. 유니코드 공백은 `strip()`을 사용하세요(JDK 11+).  
> `TrimStart/End(char)`에 정확히 대응하는 **리터럴 버전**은 Java에 없음 → 정규식 `replaceAll("^\\{+", "")` 처럼 표현합니다.

---

## 3) C++로 대응 (표준만)

### 3.1 Trim/TrimStart/TrimEnd 구현 (정규식 없이 빠르게)
```cpp
#include <string>
#include <string_view>
#include <cctype>
#include <algorithm>

inline bool is_space(unsigned char c){ return std::isspace(c) != 0; }

inline void ltrim_inplace(std::string& s){
  s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char c){ return !is_space(c); }));
}
inline void rtrim_inplace(std::string& s){
  s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char c){ return !is_space(c); }).base(), s.end());
}
inline void trim_inplace(std::string& s){ ltrim_inplace(s); rtrim_inplace(s); }

inline std::string trim_copy(std::string s){ trim_inplace(s); return s; }

// 특정 문자만 제거하는 TrimStart/TrimEnd (C#의 char 인자 대응)
inline void ltrim_char_inplace(std::string& s, char ch){
  size_t i = 0; while (i < s.size() && s[i] == ch) ++i; s.erase(0, i);
}
inline void rtrim_char_inplace(std::string& s, char ch){
  size_t e = s.size(); while (e>0 && s[e-1]==ch) --e; s.erase(e);
}
```

사용:
```cpp
std::string a = "  hello  ";
trim_inplace(a); // "hello"

std::string b = "{(Hi*";
ltrim_char_inplace(b, '{'); // "(Hi*"
rtrim_char_inplace(b, '*'); // "{(Hi"
```

### 3.2 Replace (리터럴, 모든 발생치환)
```cpp
#include <string>

inline std::string replace_all(std::string s, std::string_view from, std::string_view to){
  if (from.empty()) return s;
  size_t pos = 0;
  while ((pos = s.find(from, pos)) != std::string::npos){
    s.replace(pos, from.size(), to);
    pos += to.size(); // 겹침 방지
  }
  return s;
}
```
사용:
```cpp
std::string text = "I hope you could come with us";
auto out = replace_all(text, "hope", "wish"); // "I wish you could come with us"
```

### 3.3 ToUpper/ToLower (ASCII 안전 버전)
```cpp
#include <string>
#include <algorithm>
#include <cctype>

inline std::string ToUpper(std::string s){
  std::transform(s.begin(), s.end(), s.begin(),
    [](unsigned char c){ return static_cast<char>(std::toupper(c)); });
  return s;
}
inline std::string ToLower(std::string s){
  std::transform(s.begin(), s.end(), s.begin(),
    [](unsigned char c){ return static_cast<char>(std::tolower(c)); });
  return s;
}
```
> ⚠️ 위 구현은 **바이트 단위(ASCII)** 입니다. UTF-8 전각/다국어 케이스 매핑은 **ICU**가 필요합니다.

### 3.4 Insert/Remove (가변 문자열)
```cpp
std::string s = "01234ABC567";
s.erase(5, 3);                      // Remove(5,3) → "01234567"

std::string t = "012345";
t.insert(2, "abc");                 // Insert → "01abc2345"
```

---

## 4) 미세 차이 & 주의점

- **공백 정의**
  - C#: `Trim()`은 **유니코드 공백**도 제거
  - Java: `trim()`은 **ASCII**, `strip()`은 **유니코드**
  - C++: 기본은 없음 → 어떤 공백을 제거할지 구현에 달림(예시는 `std::isspace` = 로캘 의존 ASCII 기반)
- **불변성**
  - C#/Java `String`은 불변 → `Replace`, `Insert`, `Remove`는 **새 인스턴스 반환**
  - C++ `std::string`은 가변 → `erase/insert/replace`가 **제자리 수정**
- **정규식 vs 리터럴**
  - Java `replaceAll`은 **정규식**. 리터럴 치환은 `replace` 또는 `Pattern.quote(...)` 사용.
  - C++ `<regex>`는 무겁습니다. **리터럴 치환 루프**를 선호.
- **유니코드 대소문자**
  - 정확한 케이스 매핑/폴딩은 **ICU/Boost.Locale** 사용 검토.

---

## 5) 요약 맵핑표

| C# | Java | C++ |
|---|---|---|
| `s.Trim()` | `s.strip()`(JDK 11+) / `s.trim()`(ASCII) | `trim_inplace(s)` / `trim_copy(s)` |
| `s.TrimStart()` | `s.stripLeading()` | `ltrim_inplace(s)` |
| `s.TrimEnd()` | `s.stripTrailing()` | `rtrim_inplace(s)` |
| `s.TrimStart('{')` | `s.replaceAll("^\\{+", "")` | `ltrim_char_inplace(s,'{')` |
| `s.TrimEnd('*')` | `s.replaceAll("\\*+$", "")` | `rtrim_char_inplace(s,'*')` |
| `s.Replace("a","b")` | `s.replace("a","b")` | `replace_all(s,"a","b")` |
| `s.Insert(i,"x")` | `new StringBuilder(s).insert(i,"x")` | `s.insert(i,"x")` |
| `s.Remove(i,n)` | `new StringBuilder(s).delete(i,i+n)` / `substring` 조합 | `s.erase(i,n)` |
| `s.ToUpper()` | `s.toUpperCase(Locale.ROOT)` | `ToUpper(s)`(ASCII) |

---

## 6) 실무 팁

- **성능**: C++에서 `<regex>` 대신 직접 루프. Java에서도 정규식은 캐싱/미리 컴파일(`Pattern`) 고려.
- **안전**: C++ `std::toupper/tolower`에는 **`unsigned char` 캐스팅** 필수.
- **문화권**: UI/검색 등 문화권 민감 처리 시 C#: `CultureInfo`, Java: `Locale`, C++: ICU 사용.


## 7) C++ ICU
ICU는 International Components for Unicode의 약자로, 유니코드 및 국제화(i18n)를 지원하는 C++ 및 C용 라이브러리.
다양한 언어와 지역에 맞는 텍스트 처리 기능을 제공해서, 글로벌 애플리케이션을 개발할 때 아주 유용하다.
### 🌍 ICU의 주요 기능
- 문자열 처리: 유니코드 기반의 문자열 비교, 정렬, 검색 등
- 지역화 지원: 날짜, 시간, 숫자, 통화 등의 지역별 포맷 처리
- 문자 인코딩 변환: UTF-8, UTF-16 등 다양한 인코딩 간 변환
- 정규 표현식: 유니코드-aware 정규식 지원
- 문자열 정규화: NFC, NFD 등 유니코드 정규화 형식 지원
- 언어별 텍스트 분할: 단어, 문장, 줄바꿈 등을 언어에 맞게 분할
### 💡 예시 코드 (C++)
이 코드는 ICU를 사용해서 유니코드 문자열을 UTF-8로 변환하고 출력하는 간단한 예.

```cpp
#include <unicode/unistr.h>
#include <iostream>

int main() {
    icu::UnicodeString str = UNICODE_STRING_SIMPLE("안녕하세요");
    std::string utf8;
    str.toUTF8String(utf8);
    std::cout << utf8 << std::endl;
    return 0;
}
```

