# 🧱 구조체(Structure) 개념 비교: C# vs C++ vs Java

| 항목               | C# 구조체 (`struct`)                         | C++ 구조체 (`struct`)                         | Java 구조체 (❌ 없음)                  |
|--------------------|-------------------------------------------|--------------------------------------------|-------------------------------------------|
| 존재 여부          | ✅ 존재 (값 형식)                          | ✅ 존재 (클래스와 거의 동일)                   | ❌ 없음 (모든 객체는 참조형)              |
| 메모리 할당 방식   | Stack (기본적으로 값 형식)                   | Stack 또는 Heap (사용 방식에 따라 다름)        | Heap (모든 객체는 참조형으로 Heap에 저장) |
| 복사 방식          | 값 복사 (복제됨)                           | 값 복사 (복제됨)                               | 참조 복사 (주소만 복사됨)               |
| 상속 가능 여부     | ❌ 불가능 (struct는 클래스 상속 불가)         | ✅ 가능 (struct도 클래스처럼 상속 가능)         | ❌ 구조체 없음                         |
| 인터페이스 구현    | ✅ 가능                                    | ✅ 가능                                      | ❌ 구조체 없음                      |
| 기본 생성자 정의   | ❌ 불가능 (사용자 정의 생성자만 가능)         | ✅ 가능                                        | ❌ 구조체 없음                          |
| Nullable 지원      | ✅ `Nullable<T>` 또는 `T?` 사용 가능          | ❌ 직접 지원 없음 (포인터로 유사하게 처리 가능) | ❌ 구조체 없음                         |
| 용도               | 작은 데이터 중심 구조, 성능 최적화           | 데이터 구조 또는 클래스 대체용                 | 클래스만 사용                           |


## 🔍 C# 구조체의 핵심 특징
- 값 형식(Value Type): 클래스와 달리 참조가 아닌 값 자체를 저장
- 복사 시 독립적 인스턴스 생성: a = b 하면 a와 b는 완전히 분리된 복사본
- Stack에 저장: 메모리 할당이 빠르고 해제가 자동
- Nullable 지원: Vector?, Nullable<Vector>처럼 null 가능
- 상속 불가: 클래스처럼 상속은 안 되지만 인터페이스는 구현 가능
- 작은 데이터 구조에 적합: 예: 좌표, 색상, 벡터 등

## 🧠 예시로 보는 값 복사
```csharp
MyPoint a = new MyPoint(1, 3);
MyPoint b = a;   // 값 복사
a.X = 80;

Console.WriteLine(b.X); // 출력: 1 (a와 b는 서로 다른 복사본)
```

- a.X를 변경해도 b.X는 영향을 받지 않음
- 이는 참조형 클래스와는 완전히 다른 동작 방식


##  참고 소스
```csharp

namespace  GrammarTest
{
    public class Program
    {
        public struct  Vector
        {
            public int x;
            public int y;
            public int z;
        }
        
        public static void Main(String[] args)
        {
            Vector? v2 = null;
            Nullable<Vector> v3 = null;

            Vector v4;
            v4.x = 1;
            v4.y = 2;
            v4.z = 3;

            Console.WriteLine($"{v4.x} {v4.y} {v4.z}");
            //1 2 3

            Vector v5 = v4;
            Console.WriteLine($"{v5.x} {v5.y} {v5.z}");
            //1 2 3

            v5.x = 12;
            Console.WriteLine($"{v4.x} {v4.y} {v4.z}"); 
            //1 2 3
            
            Console.WriteLine($"{v5.x} {v5.y} {v5.z}");
            //12 2 3
        }
    }
}

```

## ✨ 왜 구조체가 중요한가?
- 성능 최적화: 작은 데이터 구조를 Heap에 할당하지 않고 Stack에서 처리
- 불변성 유지: 복사로 인해 원본이 변경되지 않음
- 메모리 효율: 참조형보다 메모리 접근이 빠르고 간단
