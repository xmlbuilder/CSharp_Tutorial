# 🧠 C# Expression Tree 핵심 요약

```csharp
Expression<Func<int, bool>> expr = num => num < 5;
```

- Expression<Func<int, bool>>는 실행 가능한 코드가 아니라 코드의 구조를 표현한 트리입니다.
- expr.Compile()을 호출하면 실제 함수로 변환되어 실행할 수 있어요.
- Expression Tree는 ParameterExpression, BinaryExpression, ConstantExpression 등으로 구성되며, 이를 통해 코드의 의미를 분석하거나 수정할 수 있습니다.

## 🔍 Expression Tree 구조 분석 예시
```csharp
ParameterExpression param = (ParameterExpression)expTree.Parameters[0];
BinaryExpression operation = (BinaryExpression)expTree.Body;
ParameterExpression left = (ParameterExpression)operation.Left;
ConstantExpression right = (ConstantExpression)operation.Right;

Console.WriteLine($"{param.Name} => {left.Name} {operation.NodeType} {right.Value}");
```


이 코드는 num => num < 5라는 식을 다음과 같이 분해합니다:
- param.Name: "num"
- operation.NodeType: ExpressionType.LessThan
- right.Value: 5

## 샘플 코드
```csharp
Expression<Func<int, bool>> expTree = num => num < 5;

ParameterExpression param = (ParameterExpression) expTree.Parameters[0];
BinaryExpression operation = (BinaryExpression) expTree.Body;
ParameterExpression left = (ParameterExpression) operation.Left;
ConstantExpression right = (ConstantExpression) operation.Right;
Console.WriteLine($"Decomposed expression : {param.Name} => {left.Name}, {operation.NodeType}, {right.Value}");

using System;
using System.Linq.Expressions;
namespace  GrammarTest
{
    public class Program
    {
        class PrintingVisitor : ExpressionVisitor
        {
            protected override Expression VisitConstant(ConstantExpression node)
            {
                Console.WriteLine($"Constant : {node}");
                return base.VisitConstant(node);
            }
            protected override Expression VisitParameter(ParameterExpression node)
            {
                Console.WriteLine($"Parameter : {node}");
                return base.VisitParameter(node);
            }
            protected override Expression VisitBinary(BinaryExpression node)
            {
                Console.WriteLine($"Binary with operator : {node.NodeType}");
                return base.VisitBinary(node);
            }
        }
        
        public static void Main(String[] args)
        {
            Expression<Func<int, bool>> isBig = a => a > 10000;
            var visitor = new PrintingVisitor();
            visitor.Visit(isBig);
        }
    }
}

```


## 🧭 다른 언어에서의 유사 기능
### ✅ C++: Expression Tree는 직접 구현해야 함
C++에는 내장된 Expression Tree 기능은 없지만, 다음과 같은 방식으로 유사한 구조를 만들 수 있어요:
- 템플릿 + 함수 포인터 + AST 클래스 직접 구현
- Clang AST 또는 LLVM IR을 활용한 코드 분석
- 예시 구조:

```cpp
struct Expr {
    virtual bool evaluate(int x) = 0;
};

struct LessThanExpr : Expr {
    int value;
    LessThanExpr(int v) : value(v) {}
    bool evaluate(int x) override { return x < value; }
};
```

C++에서는 런타임에 코드 구조를 분석하는 기능은 제한적이며, 대부분 컴파일 타임 또는 외부 도구를 사용합니다.


### ✅ Java: MethodHandle, LambdaMetafactory, 또는 ASM 라이브러리
Java는 C#처럼 Expression Tree를 직접 제공하지 않지만, 다음과 같은 방식으로 유사한 기능을 구현할 수 있어요:
- Reflection API: 메서드나 람다의 구조를 일부 분석 가능
- ASM / Javassist: 바이트코드 수준에서 AST처럼 다룰 수 있음
- Java 8+의 LambdaMetafactory: 런타임에 람다 생성 가능
Predicate<Integer> pred = x -> x < 5;
System.out.println(pred.test(4)); // true


하지만 Java에서는 람다의 내부 구조를 직접 분석하는 기능은 제한적입니다. 
바이트코드 조작이 필요할 수 있어요.


### ✅ Python: ast 모듈로 코드 구조 분석
Python은 C#처럼 코드를 데이터로 다루는 기능이 매우 강력합니다. ast 모듈을 사용하면 Expression Tree처럼 코드 구조를 분석할 수 있어요.
import ast

code = "lambda x: x < 5"
tree = ast.parse(code, mode='eval')

print(ast.dump(tree, indent=4))


### 🔍 출력 예시
Expression(
    body=Lambda(
        args=arguments(...),
        body=Compare(
            left=Name(id='x', ...),
            ops=[Lt()],
            comparators=[Constant(value=5)]
        )
    )
)


Python에서는 ast.NodeVisitor를 상속해서 C#의 ExpressionVisitor처럼 트리를 순회할 수 있어요.


### 🧾 요약 비교 (Markdown 표)
| 언어    | Expression Tree 지원 | 주요 기능 및 제한사항 |
|---------|----------------------|------------------------|
| **C#**  | ✅ `System.Linq.Expressions` | 코드 구조를 런타임에 분석/조작 가능. 컴파일도 가능. |
| **C++** | ❌ 직접 구현 필요     | AST 직접 구현하거나 Clang/LLVM 사용. 복잡함. |
| **Java**| ⚠️ 제한적 지원       | Reflection 또는 바이트코드 조작 필요. |
| **Python**| ✅ `ast` 모듈       | 코드 구조를 쉽게 분석하고 트리 순회 가능. |




C#에서 코드를 "직접 열어서 실행"하는 방식은 여러 가지가 있는데, 
그 중 Expression Tree는 일부 역할을 할 수 있지만, 전체적인 코드 실행에는 다른 기술들이 더 많이 사용돼요.

## 🧠 Expression Tree는 "코드 구조 분석"에 특화
Expression Tree (Expression<Func<T>>)는 코드의 구조를 객체로 표현하는 방식이에요. 예를 들어 x => x < 5 같은 람다식을 트리 형태로 저장하고, 그 구조를 분석하거나 수정할 수 있죠.
하지만 Expression Tree는 제한된 범위의 코드만 표현 가능해요:
- 주로 람다식, 수식, 간단한 메서드 호출 정도
- if, for, try-catch 같은 제어문은 표현 불가
- 전체 프로그램이나 클래스 구조를 표현하려면 다른 방식이 필요해요

## 🚀 C#에서 "코드를 직접 열어서 실행"하는 주요 방식들
### 1. Roslyn (C# Compiler Platform)
- C# 코드를 문자열로 받아서 컴파일하고 실행할 수 있는 API
- Microsoft.CodeAnalysis.CSharp.Scripting을 사용하면 스크립트처럼 실행 가능
```csharp
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;

var result = await CSharpScript.EvaluateAsync<int>("1 + 2");
Console.WriteLine(result); // 출력: 3
```

Roslyn은 Expression Tree보다 훨씬 강력해서 전체 C# 문법을 지원하고, 런타임에 코드를 분석하거나 수정할 수 있어요.


### 2. Reflection.Emit / ILGenerator
- 런타임에 IL 코드를 직접 생성해서 메서드나 타입을 만들 수 있음
- 매우 저수준이지만 강력함
- Expression Tree와 함께 쓰이기도 함

### 3. CodeDom (구버전)
- C# 코드를 문자열로 받아서 컴파일하고 실행하는 방식
- .NET Core 이후에는 거의 사용되지 않음

## 🔍 Expression vs Roslyn 비교

| 항목                         | Expression Tree                              | Roslyn (C# Scripting / Compiler API)             |
|------------------------------|-----------------------------------------------|--------------------------------------------------|
| 목적                         | 코드 구조 분석 및 동적 함수 생성              | 전체 C# 코드 분석, 컴파일, 실행                  |
| 코드 표현 방식               | `Expression<Func<T>>` 형태의 트리 구조        | 문자열 기반의 C# 코드                           |
| 실행 가능 여부              | `Compile()`을 통해 delegate로 실행 가능       | `CSharpScript.EvaluateAsync()` 등으로 실행 가능 |
| 지원 문법 범위              | 수식, 메서드 호출, 람다 등 제한적             | C# 전체 문법 (`if`, `for`, 클래스 등) 지원       |
| 제어문 (`if`, `for`, 등)    | ❌ 지원하지 않음                              | ✅ 완전 지원                                     |
| 코드 수정 및 생성           | 트리 노드를 수정하여 새로운 식 생성 가능      | 코드 문자열을 수정하거나 AST 조작 가능           |
| 사용 예                     | ORM, DSL, LINQ, 동적 필터링                   | REPL, 코드 실행기, 동적 로직 생성                |
| 런타임 분석/조작            | ✅ 가능 (노드 기반)                           | ✅ 가능 (구문 트리 기반)                         |
| 학습 난이도                  | 중간 (트리 구조 이해 필요)                    | 높음 (컴파일러 API 이해 필요)                   |



## 🧩 결론
Expression Tree는 코드의 구조를 다루는 도구이고, 실제로 "코드를 열어서 실행"하는 데는 Roslyn이나 스크립트 엔진이 더 적합해요. 만약 C# 코드 조각을 런타임에 받아서 실행하거나, 사용자 입력을 기반으로 동적 로직을 만들고 싶다면 Roslyn을 사용하는 게 정석입니다.


## 🧪 Roslyn 콘솔 앱 예제: 사용자 입력 코드 실행
```csharp
using System;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;

namespace RoslynRuntimeEval
{
    class Program
    {
        static async Task Main(string[] args)
        {
            Console.WriteLine("🔧 C# 코드 실행기 (Roslyn 기반)");
            Console.WriteLine("예: 1 + 2 * 3 또는 Math.Pow(2, 10)");
            Console.WriteLine("종료하려면 'exit' 입력");

            while (true)
            {
                Console.Write("\n입력 > ");
                string input = Console.ReadLine();

                if (input?.Trim().ToLower() == "exit")
                    break;

                try
                {
                    var result = await CSharpScript.EvaluateAsync<object>(
                        input,
                        ScriptOptions.Default
                            .WithImports("System", "System.Math")
                            .WithReferences(typeof(object).Assembly)
                    );

                    Console.WriteLine($"결과: {result}");
                }
                catch (CompilationErrorException e)
                {
                    Console.WriteLine("⚠️ 컴파일 오류:");
                    foreach (var diag in e.Diagnostics)
                        Console.WriteLine($"  - {diag}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"❌ 실행 오류: {ex.Message}");
                }
            }

            Console.WriteLine("👋 종료합니다.");
        }
    }
}
```


## 📦 NuGet 패키지 필요
이 코드를 실행하려면 프로젝트에 다음 NuGet 패키지를 추가해야 합니다:
Microsoft.CodeAnalysis.CSharp.Scripting


Visual Studio에서는 NuGet 패키지 관리자에서 설치하거나, CLI에서는 다음 명령어 사용:

dotnet add package Microsoft.CodeAnalysis.CSharp.Scripting



## 🧠 사용 예시
입력 > 1 + 2 * 3
결과: 7

입력 > Math.Sqrt(144)
결과: 12

입력 > "Hello".ToUpper()
결과: HELLO



## 🔐 보안 주의
이 방식은 사용자 입력을 직접 실행하기 때문에, 실제 서비스에서는 반드시 샌드박싱, 입력 검증, 권한 제한이 필요합니다. 예를 들어 File.Delete(...) 같은 위험한 코드가 실행되지 않도록 해야 해요.

---

# C# 코드 블록 실행

C#에서는 Roslyn을 활용하면 외부 파일에 저장된 C# 코드 블록을 읽어서 런타임에 실행할 수 있어요.  
이건 마치 Python의 exec()처럼 동적으로 코드를 실행하는 방식인데, 훨씬 더 안전하고 정교하게 제어할 수 있습니다.

## 📁 시나리오: 코드 파일을 읽어서 실행
예를 들어, code.csx라는 파일에 다음과 같은 C# 코드가 있다고 가정:

// code.csx
int x = 10;
int y = 20;
x + y


이 파일을 콘솔 앱에서 읽고 실행하면 30이라는 결과를 얻을 수 있어요.

## 🧪 콘솔 앱 예제: Roslyn으로 .csx 파일 실행
```csharp
using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;

namespace RoslynFileRunner
{
    class Program
    {
        static async Task Main(string[] args)
        {
            Console.WriteLine("📂 실행할 C# 코드 파일 경로를 입력하세요:");
            string path = Console.ReadLine();

            if (!File.Exists(path))
            {
                Console.WriteLine("❌ 파일이 존재하지 않습니다.");
                return;
            }

            string code = await File.ReadAllTextAsync(path);

            try
            {
                var result = await CSharpScript.EvaluateAsync<object>(
                    code,
                    ScriptOptions.Default
                        .WithImports("System", "System.Math")
                        .WithReferences(typeof(object).Assembly)
                );

                Console.WriteLine($"✅ 실행 결과: {result}");
            }
            catch (CompilationErrorException e)
            {
                Console.WriteLine("⚠️ 컴파일 오류:");
                foreach (var diag in e.Diagnostics)
                    Console.WriteLine($"  - {diag}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ 실행 오류: {ex.Message}");
            }
        }
    }
}
```


🎮 Unity에서 C#이 동작하는 방식 요약
### 1. Mono 또는 IL2CPP 런타임

즉, Unity는 C# 코드를 먼저 IL로 컴파일하고, 필요에 따라 IL2CPP를 통해 C++ 코드로 변환해서 실행해요.

### 2. C# 스크립트 → 컴파일 → Unity 런타임에 로드
- 사용자가 작성한 .cs 파일은 Unity가 내부적으로 **C# 컴파일러(Roslyn 기반)**를 통해 DLL로 컴파일해요.
- 이 DLL은 Unity의 런타임에서 리플렉션을 통해 클래스와 메서드를 탐색하고, MonoBehaviour를 상속한 클래스의 Start(), Update() 같은 메서드를 자동으로 호출해요.
public class PlayerController : MonoBehaviour
{
    void Start() {
        Debug.Log("게임 시작!");
    }

    void Update() {
        // 매 프레임마다 호출됨
    }
}



### 3. Unity의 이벤트 기반 실행 모델
Unity는 C# 코드의 메서드를 직접 호출하지 않고, 이벤트 루프 기반으로 자동 실행해요:
- Awake() → 객체가 생성될 때
- Start() → 첫 프레임 전에
- Update() → 매 프레임마다
- OnCollisionEnter() → 충돌 발생 시
이런 메서드들은 Unity가 리플렉션으로 자동 탐색해서 호출해주는 구조예요.

### 4. 런타임 스크립트 실행은 제한적
Unity는 기본적으로 런타임에 C# 코드를 문자열로 받아서 실행하는 기능은 제공하지 않아요. 하지만 다음과 같은 방식으로 확장할 수 있어요:
- Roslyn을 직접 포함해서 런타임 코드 실행 기능 추가
- C# 스크립트 파일을 읽어서 컴파일 후 실행 (에디터 확장이나 툴 제작 시 사용)
- Asset Store의 Script Runtime Loader 같은 플러그인 활용

## 🔐 보안과 성능 고려
Unity는 게임 환경에서 보안과 성능이 매우 중요하기 때문에, C# 코드 실행 방식도 제한적이고 최적화되어 있어요:
- IL2CPP는 JIT 없이 AOT 컴파일로 보안 강화
- 런타임 코드 실행은 에디터에서만 허용하거나 샌드박싱 필요

## 🧠 요약
| 항목                     | Unity에서의 C# 처리 방식                                      |
|--------------------------|---------------------------------------------------------------|
| 실행 방식                | Mono 또는 IL2CPP를 통해 C# 코드 실행                          |
| 코드 컴파일              | `.cs` 파일을 Roslyn 기반 컴파일러로 DLL 생성 후 로드          |
| 런타임 이벤트 처리       | Unity가 `MonoBehaviour` 메서드를 자동 탐색 및 호출             |
| 런타임 코드 실행         | 기본적으로 불가능 (Roslyn 포함 시 가능)                        |
| IL2CPP 사용 목적         | IL → C++ 변환 후 네이티브 컴파일로 성능 및 보안 강화          |
| 코드 수정 가능 여부      | 에디터에서는 가능, 런타임에서는 제한적                         |
| 보안 및 샌드박싱         | JIT 제거, IL2CPP 사용, 외부 코드 실행 시 보안 고려 필요         |
| 확장 가능성              | Roslyn 포함 시 사용자 스크립트 실행, 플러그인 시스템 구현 가능 |


## 🧠 Microsoft.CodeAnalysis.CSharp.Scripting이란?
이건 Roslyn의 Scripting API로, 일반적인 C# 컴파일러와 달리 스크립트처럼 동작하는 코드를 실행할 수 있게 해줘요. 즉, .cs 파일처럼 클래스나 메서드 정의 없이도 1 + 2, Console.WriteLine("Hello") 같은 코드를 바로 실행할 수 있어요.

## 🔧 핵심 기능
| 기능 항목                     | 설명                                                                 |
|------------------------------|----------------------------------------------------------------------|
| `CSharpScript.RunAsync`      | C# 코드를 런타임에 실행하고 결과 반환 (`ScriptState<T>` 포함)         |
| `CSharpScript.EvaluateAsync` | 표현식 평가 후 결과만 반환 (예: `1 + 2`)                              |
| `ScriptOptions`              | 참조 추가, `using` 지시문 설정, 파일 경로 지정 등 실행 환경 구성       |
| `ScriptState<T>`             | 실행 결과, 변수 상태, 다음 실행 컨텍스트를 포함하는 객체               |
| `Script<T>`                  | 스크립트 객체로 컴파일된 코드 표현. 여러 단계로 실행 가능              |
| `globals` 객체               | 스크립트에서 접근 가능한 외부 변수/객체를 전달하는 방식 (`globals` 타입 지정) |
| `ContinueWithAsync`          | 이전 스크립트 상태를 이어서 실행 가능. 상태 기반 시나리오에 유용       |
| `CompilationErrorException`  | 컴파일 오류 발생 시 예외 처리. 오류 메시지 및 위치 정보 제공           |
| `EmitDebugInformation`       | 디버깅 정보 포함 여부 설정 (디버깅 시 유용)                            |
| `InteractiveAssemblyLoader`  | 동적 어셈블리 로딩을 위한 커스텀 로더 설정 가능                        |



## 🧪 예제: 간단한 코드 실행
```csharp
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;

var result = await CSharpScript.EvaluateAsync<int>("1 + 2");
Console.WriteLine(result); // 출력: 3
```
- "1 + 2"는 문자열로 된 C# 코드
- EvaluateAsync가 이 코드를 컴파일하고 실행
- 결과는 int 타입으로 반환

## 🧩 예제: 외부 API 주입 (globals)
```cpp
public class HostAPI {
    public void Log(string msg) => Console.WriteLine($"[Script] {msg}");
}

var globals = new HostAPI();

await CSharpScript.RunAsync(
    @"Log(""스크립트에서 호출됨!"");",
    ScriptOptions.Default.WithImports("System"),
    globals: globals
);
```

- 스크립트에서 Log()를 호출하면 HostAPI의 메서드가 실행됨
- 이 방식으로 앱의 기능을 스크립트에 노출할 수 있음

## 🧠 내부 동작 흐름
- 문자열 코드 입력
- Roslyn이 구문 분석 → 컴파일 → 실행
- 결과를 반환하거나 상태를 유지 (ScriptState)
- 오류 발생 시 CompilationErrorException으로 처리

## 🔐 보안과 제약
- 기본적으로 JIT 컴파일을 사용하므로 빠르고 유연함
- 하지만 사용자 입력을 실행할 경우 보안 위험 존재
- ScriptOptions에서 참조 제한, 네임스페이스 제한 가능
- 고급 시나리오에서는 AppDomain 격리 또는 샌드박스 필요

## 🎯 언제 사용하나요?
- 사용자 정의 스크립트 실행기
- 플러그인 시스템
- 테스트 자동화
- DSL (도메인 특화 언어) 구현
- 게임/툴에서 사용자 확장 기능 제공 (Rhino, Unity Editor 등)



## ✅ Roslyn에서 using을 사용하려면?
스크립트 코드에서 using MyNamespace;를 사용하려면, 해당 네임스페이스가 포함된 DLL을 참조로 추가해야 해요. 그리고 ScriptOptions.WithImports(...)를 통해 using을 미리 지정하거나, 코드 안에 직접 using을 써도 됩니다.

## 🧪 예제: 내가 만든 DLL을 using으로 사용하는 방법
### 1. 예시 DLL 코드 (MyLibrary.dll)
```csharp
namespace MyLibrary {
    public static class MathUtil {
        public static int Add(int a, int b) => a + b;
    }
}
```

### 2. Roslyn 스크립트 실행 코드
```csharp
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;
using System.Reflection;

var assembly = Assembly.LoadFrom("MyLibrary.dll");

var options = ScriptOptions.Default
    .WithReferences(assembly)
    .WithImports("System", "MyLibrary");

string code = @"
using MyLibrary;
var result = MathUtil.Add(10, 20);
result
";

var result = await CSharpScript.EvaluateAsync<int>(code, options);
Console.WriteLine($"결과: {result}"); // 출력: 결과: 30
```



## 🔍 핵심 포인트
| 항목                         | 설명                                                                 |
|------------------------------|----------------------------------------------------------------------|
| DLL 참조 추가                | `ScriptOptions.WithReferences(...)`로 외부 DLL을 스크립트에 연결       |
| `using` 네임스페이스 사용    | 코드 내 `using` 또는 `WithImports(...)`로 네임스페이스 지정 가능       |
| 소스 포함 여부               | DLL에 소스가 포함되어 있어도 Roslyn은 IL만 사용 (소스 직접 실행은 아님) |
| DLL 경로                     | 절대 경로 또는 실행 디렉터리 기준 상대 경로 사용 가능                  |
| 타입 및 메서드 접근          | DLL에 정의된 클래스/메서드는 네임스페이스와 함께 정확히 지정해야 사용 가능 |
| .NET 버전 호환성             | DLL은 현재 실행 환경과 호환되는 .NET 타겟이어야 함                     |
| 보안 고려                    | 외부 DLL 실행 시 샌드박싱 또는 API 제한 필요                          |



## ⚠️ 주의사항
- DLL이 현재 실행 환경과 호환되는 .NET 버전이어야 해요.
- using을 쓰더라도 참조가 없으면 컴파일 오류가 발생합니다.
- ScriptOptions에 WithReferences와 WithImports를 정확히 설정해야 해요.

---

# 🧠 Java에서 런타임 코드 실행이 가능한 방식
## ✅ 1. Java Compiler API (javax.tools.JavaCompiler)
- Java 6부터 제공되는 표준 API
- 문자열로 된 Java 코드를 런타임에 컴파일하고 클래스 로딩 가능
JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
compiler.run(null, null, null, "MyScript.java");


이 방식은 실제 .java 파일을 생성하거나 메모리 내에서 컴파일할 수 있어요.


## ✅ 2. JShell (Java 9+)
- Java에 내장된 REPL 환경
- 코드 조각을 즉시 실행 가능
- API를 통해 프로그램 내에서 JShell을 제어할 수 있음
JShell shell = JShell.create();
List<SnippetEvent> events = shell.eval("1 + 2");


JShell은 Roslyn의 EvaluateAsync()와 비슷한 역할을 합니다.


## ✅ 3. BeanShell / Janino / Groovy
- Java 기반의 스크립트 엔진을 내장하거나 연동
- BeanShell: Java 문법에 가까운 스크립트 언어
- Janino: 매우 빠른 Java 컴파일러
- Groovy: JVM 기반의 동적 언어로 Java와 완벽 호환
Interpreter interpreter = new Interpreter();
interpreter.eval("System.out.println(\"Hello from BeanShell\")");



## 🔍 요약 비교 (Markdown 표)
| 방식           | 설명                                       | 특징 및 제한사항                          |
|----------------|--------------------------------------------|-------------------------------------------|
| JavaCompiler   | Java 소스 문자열을 런타임에 컴파일         | 클래스 로딩 필요, 복잡한 설정 가능        |
| JShell         | Java 9+ 내장 REPL                          | 간단한 코드 실행에 적합, 상태 유지 가능   |
| BeanShell      | Java-like 스크립트 엔진                    | 가볍고 빠름, Java 문법과 유사              |
| Janino         | 초경량 Java 컴파일러                       | 빠른 컴파일, 제한된 문법 지원              |
| Groovy         | JVM 기반 동적 언어                         | 강력한 기능, Java와 완전 호환              |



## 🎯 결론
Java에서도 Roslyn처럼 동적으로 코드를 실행하는 기능은 충분히 구현 가능합니다.  
다만 Roslyn처럼 정적 분석, 코드 리팩토링, AST 조작까지 가능한 통합 플랫폼은 내장되어 있지 않아요.  
대신 Java는 다양한 외부 도구와 스크립트 엔진을 통해 유연하게 확장할 수 있습니다.

