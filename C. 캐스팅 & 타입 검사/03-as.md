# 🧠 C# as 연산자 요약
- 형식 변환 시 실패하면 null 반환
- 예외 발생하지 않음
- 참조 타입에만 사용 가능
- 하향 캐스팅(downcasting)에 자주 사용됨

```csharp
Student? student = human as Student;
if (student != null) student.Print();
```

## 전체 소스
```csharp
namespace GrammarTest
{
    public class GrammarTest
    {
        class Human
        {
            public virtual void Print()
            {
                Console.WriteLine("Human");
            }
        }

        class Student : Human
        {
            public override void Print()
            {
                Console.WriteLine("Student");
            }
        }

        public static void Main(String[] args)
        {
            Human human = new Human();
            Student student = new Student();
            Student student2 = new Student();
            Human? hum1 = student as Human;
            hum1?.Print();
            //Student

            Human hum2 = new Student();
            Student? student3 = hum2 as Student;
            student3?.Print();
            //Student

            Human? hum3 = new Human();
            Student? student4 = hum3 as Student;

            Console.WriteLine(student4 == null);
            //True

            student4?.Print();


        }
    }
}
```


## ☕ Java에서의 유사 기능
Java에는 as 연산자는 없지만, instanceof + 명시적 캐스팅으로 같은 효과를 낼 수 있어요.
```java
class Human {
    public void print() {
        System.out.println("Human");
    }
}

class Student extends Human {
    @Override
    public void print() {
        System.out.println("Student");
    }
}

public class Main {
    public static void main(String[] args) {
        Human hum = new Student();

        if (hum instanceof Student) {
            Student student = (Student) hum;
            student.print(); // Student
        }

        Human hum2 = new Human();
        if (hum2 instanceof Student) {
            Student student2 = (Student) hum2;
            student2.print(); // 실행 안 됨
        } else {
            System.out.println("student2 is null"); // 유사한 null 체크
        }
    }
}
```

### ✅ 특징
- instanceof로 타입 확인
- 명시적 캐스팅 필요
- 실패 시 ClassCastException 방지 가능

## 💻 C++에서의 유사 기능
C++에서는 **dynamic_cast**를 사용하면 C#의 as와 거의 동일한 동작을 구현할 수 있어요.
```cpp
#include <iostream>
using namespace std;

class Human {
public:
    virtual void Print() {
        cout << "Human" << endl;
    }
    virtual ~Human() = default;
};

class Student : public Human {
public:
    void Print() override {
        cout << "Student" << endl;
    }
};

int main() {
    Human* hum1 = new Student();
    Student* student1 = dynamic_cast<Student*>(hum1);
    if (student1) student1->Print(); // Student

    Human* hum2 = new Human();
    Student* student2 = dynamic_cast<Student*>(hum2);
    if (student2) student2->Print();
    else cout << "student2 is null" << endl; // null 반환됨

    delete hum1;
    delete hum2;
}
```

### ✅ 특징
- dynamic_cast는 런타임 타입 확인을 수행
- 실패 시 nullptr 반환 → C#의 as와 동일한 동작
- 반드시 기준 클래스에 virtual 함수가 있어야 함 (RTTI 필요)

## 🧭 비교 요약
| 언어 | 기능 | 실패 시 | 타입 확인 방식 |
|------|-----|--------|--------------| 
| C# | as | null | 자동 | 
| Java | instanceof + 캐스팅 | 예외 or null 체크 | 수동 | 
| C++ | dynamic_cast | nullptr | RTTI 기반 |
---





