# 📘 `static` 키워드 완전 정리: C#, C++, Java 비교

## 🧠 공통 개념

- `static`은 **클래스나 함수의 인스턴스와 무관하게 공유되는 메모리 공간**을 의미합니다.
- 객체 없이도 접근 가능하며, **프로그램 실행 시점에 메모리에 올라가고 종료 시까지 유지**됩니다.
- 하지만 언어마다 **메모리 위치, 초기화 방식, 접근 범위**가 다릅니다.

---

## 🧩 C++에서의 `static`

### ✅ 사용 위치와 의미

| 위치             | 의미                  | 메모리 영역             |
|------------------|-----------------------|--------------------------|
| 함수 내부        | 호출 간 값 유지       | 데이터 영역 (`.data` / `.bss`) |
| 클래스 내부      | 클래스 단위 공유       | 데이터 영역             |
| 파일 스코프 (.cpp) | 외부 링크 방지         | 데이터 영역             |
| 헤더 파일        | TU마다 복사본 생성     | 데이터 영역 (복수 생성) |

### ✅ 초기화 방식

- 정적 변수는 **프로그램 시작 시 초기화**됩니다.
- 클래스 내부 `static` 멤버는 **정의와 초기화가 별도로 필요**합니다.

```cpp
class MyClass {
public:
    static int count;
};

int MyClass::count = 0; // 반드시 cpp 파일에 정의
```

### ⚠️ 주의점
- 정적 초기화 순서 문제 발생 가능
- 여러 .cpp 파일에서 static 변수 간 의존성이 생기면 예측 불가능한 동작이 발생할 수 있습니다.

## ☕ Java에서의 static
### ✅ Java에서 static 사용 위치와 의미

| 위치         | 의미             | 메모리 영역               |
|--------------|------------------|----------------------------|
| 클래스 내부  | 클래스 단위 공유 | 메서드 영역 (Method Area) |
| static block | 클래스 로딩 시 실행 | 메서드 영역               |

---


### ✅ 초기화 방식
- 클래스가 JVM에 로딩될 때 static 변수와 static block이 초기화됩니다.
- 순서는 정의된 순서대로 실행됩니다.

```java
class Example {
    static int count = 0;

    static {
        count = 42;
        System.out.println("Static block executed");
    }
}
```

### ⚠️ 주의점
- static은 객체 없이 접근 가능합니다.
- JVM이 클래스 로딩 시점에 자동으로 초기화 순서를 보장합니다.

## ☁️ C#에서의 static
### ✅ C#에서 static 사용 위치와 의미

| 위치               | 의미                  | 메모리 영역           |
|--------------------|-----------------------|------------------------|
| 클래스 내부        | 클래스 단위 공유       | 힙 또는 CLR 관리 영역 |
| static class       | 인스턴스 생성 불가     | CLR 관리 영역         |
| static constructor | 클래스 로딩 시 실행   | CLR 관리 영역         |

---



### ✅ 초기화 방식
- 클래스가 처음 사용될 때 static 생성자 실행됩니다.
- static 생성자는 한 번만 호출되며, 명시적으로 호출할 수 없습니다.

```csharp
class Example {
    public static int count;

    static Example() {
        count = 42;
        Console.WriteLine("Static constructor executed");
    }
}
```

### ⚠️ 주의점
- static 클래스는 인스턴스 생성이 불가능합니다.
- static 생성자는 예외 처리 불가능하며 실패 시 프로그램이 종료됩니다.

## 🧭 메모리 구조 비교

| 언어 | static 저장 위치         | 초기화 시점           | 공유 범위         |
|------|--------------------------|------------------------|--------------------|
| C++  | 데이터 영역 (.data/.bss) | 프로그램 시작 시       | 클래스/파일 단위   |
| Java | 메서드 영역              | 클래스 로딩 시         | 클래스 단위       |
| C#   | CLR 관리 영역            | 클래스 최초 사용 시     | 클래스 단위       |



## 🔥 추가 팁
- C에서는 static 대신 inline static (C17)으로 헤더 정의 가능
- Java와 C#은 static 초기화 순서를 보장하지만, C++은 불확실
- C#의 static은 Thread-safe 초기화가 자동으로 보장됨
- C++에서는 Singleton 패턴으로 초기화 순서 문제를 우회 가능


## 🔍 함수 내부에서 static 변수 이름이 겹쳐도 되는 이유
```cpp
void foo() {
    static int counter = 0; // foo() 안에서만 접근 가능
}

void bar() {
    static int counter = 0; // bar() 안에서만 접근 가능
}
```

## ✅ 이유: 블록 스코프 + 내부 링크
- static 변수는 정적 저장 공간에 저장되지만,
함수 내부에 정의되면 해당 함수의 스코프 안에서만 접근 가능해요.
- 즉, foo()의 counter와 bar()의 counter는 이름은 같지만 서로 다른 변수예요.
- 외부에서는 접근할 수 없고, 함수 호출 간 값을 유지하는 용도로만 쓰이죠.

## 🔍 파일 스코프에서 static 변수 이름이 겹쳐도 되는 이유
// file1.cpp
static int value = 42; // file1.cpp 안에서만 접근 가능

// file2.cpp
static int value = 99; // file2.cpp 안에서만 접근 가능


## ✅ 이유: 내부 링크(internal linkage)
- static을 파일 스코프에서 쓰면 그 변수는 해당 번역 단위(TU) 안에서만 보임.
- 즉, file1.cpp의 value와 file2.cpp의 value는 전혀 다른 변수로 취급돼요.
- 링커는 외부에서 이 이름을 참조할 수 없기 때문에 이름 충돌이 발생하지 않아요.

## 🧠 static 변수 이름이 겹쳐도 되는 이유

| 위치           | static의 역할                      | 이름 충돌 여부 |
|----------------|------------------------------------|----------------|
| 함수 내부      | 호출 간 값 유지, 블록 스코프       | ❌ 없음        |
| 파일 스코프    | 외부 링크 방지, 내부 링크           | ❌ 없음        |
| 클래스 내부    | 클래스 단위 공유, 전역처럼 사용     | ⚠️ 클래스 내에서만 충돌 가능 |

---


