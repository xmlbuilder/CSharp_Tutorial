# 🔍 제네릭 타입 명시의 필요성

## 코드 분석
```csharp
public static int SomeMethod<T, V>(V ang)
{
    return 0;
}
```
## 전체코드
```csharp
public static int SomeMethod<T, V>(V ang)
{
    return 0;
}
        
static void Main(string[] args)
{
    //int num1 = SomeMethod(3); //Compile Error
    //int num2 = SomeMethod<int>("3"); //Compile Error
    int num3 = SomeMethod<int, string>("3"); 
}
```


- 이 메서드는 **두 개의 제네릭 타입 매개변수 T와 V**를 사용합니다.
- 하지만 실제 메서드 본문에서는 V ang만 사용되고, T는 사용되지 않습니다.
- 따라서 컴파일러는 T의 타입을 추론할 수 없습니다.

## ⚠️ 왜 타입을 명시해야 하나요?
### ❌ SomeMethod(3) → 컴파일 오류
- 타입 인자를 생략했기 때문에 컴파일러는 T와 V를 추론하려고 시도합니다.
- V는 int로 추론되지만, T는 사용되지 않기 때문에 추론 불가능 → 오류 발생
### ❌ SomeMethod<int>("3") → 컴파일 오류
- T는 int로 명시했지만, V는 명시하지 않았습니다.
- "3"은 string이므로 V를 string으로 추론해야 하는데, T만 명시되어 있어 불완전한 타입 지정 → 오류 발생
### ✅ SomeMethod<int, string>("3") → 정상 컴파일
- T는 int, V는 string으로 명시적으로 지정
- "3"은 string이므로 V ang에 잘 들어맞음 → 컴파일 성공

## 📌 핵심 요점
| 호출 방식                          | 타입 추론 가능 여부 | 설명 |
|-----------------------------------|--------------------|------|
| `SomeMethod(3)`                   | ❌ 불가능           | `V`는 `int`로 추론되지만, `T`는 사용되지 않아 추론 불가 |
| `SomeMethod<int>("3")`           | ❌ 불가능           | `T`는 명시했지만, `V`는 추론해야 하므로 불완전한 타입 지정 |
| `SomeMethod<int, string>("3")`   | ✅ 가능             | `T`와 `V` 모두 명시되어 타입이 완전히 지정됨 |


## 💡 결론
제네릭 타입 매개변수 중 하나라도 코드 내에서 사용되지 않으면, 해당 타입은 반드시 명시적으로 지정해야 합니다.
이는 컴파일러가 타입을 추론할 수 없기 때문이며, 타입 안정성과 명확성을 확보하기 위한 C#의 설계 철학이기도 해요.
