# 🧾 C# 으로 Split 과 Parser 조합 

## C# 코드 요약

```csharp
using System;
using System.IO;

struct GRADE
{
    public int kor;
    public int eng;
    public int math;
    public int total;
    public float average;
}

class Program
{
    static void Main()
    {
        // 예시 문자열 파싱
        string str = "국어: 90 영어: 100 수학: 70";
        string[] str_Element = str.Split(new char[] { ' ' });

        int kor = int.Parse(str_Element[1]);
        int eng = int.Parse(str_Element[3]);
        int math = int.Parse(str_Element[5]);

        int total = kor + eng + math;
        float average = total / 3.0f;

        Console.WriteLine("{0} {1} {2} {3} {4}", kor, eng, math, total, Math.Round(average));

        // 학생 수 입력 및 성적 처리
        Console.Write("성적 처리를 위한 학생 수를 입력하세요 :");
        int nCount = int.Parse(Console.ReadLine());
        GRADE[] Grade = new GRADE[nCount];

        StreamWriter sw = new StreamWriter("test.txt");
        sw.WriteLine("학생수: {0}", nCount);

        for (int i = 0; i < nCount; i++)
        {
            str = Console.ReadLine(); // 예: "90 100 70"
            string[] DataString = str.Split(new char[] { ' ' });

            Grade[i].kor = int.Parse(DataString[0]);
            Grade[i].eng = int.Parse(DataString[1]);
            Grade[i].math = int.Parse(DataString[2]);
            Grade[i].total = Grade[i].kor + Grade[i].eng + Grade[i].math;
            Grade[i].average = (float)Math.Round(Grade[i].total / 3.0f);
        }

        for (int i = 0; i < nCount; i++)
        {
            sw.WriteLine("{0} {1} {2} {3} {4:f1}", Grade[i].kor,
                Grade[i].eng, Grade[i].math, Grade[i].total, Grade[i].average);
        }

        sw.Close();
    }
}
```

### 기능 흐름
#### - 문자열 분할
"국어: 90 영어: 100 수학: 70" → Split(' ') → [국어:, 90, 영어:, 100, 수학:, 70]
#### - 숫자 추출 및 계산
int.Parse()로 점수 추출 → 총점 및 평균 계산
- 학생 수 입력 → 반복 입력 처리
- Console.ReadLine()으로 점수 입력
- Split()으로 분할 후 int.Parse()로 저장
- StreamWriter로 결과 파일 저장

## ☕ Java로 구현
```java
import java.io.*;
import java.util.Scanner;

class Grade {
    int kor, eng, math, total;
    float average;
}

public class GradeParser {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        System.out.print("학생 수 입력: ");
        int nCount = Integer.parseInt(sc.nextLine());
        Grade[] grades = new Grade[nCount];

        BufferedWriter writer = new BufferedWriter(new FileWriter("test.txt"));
        writer.write("학생수: " + nCount);
        writer.newLine();

        for (int i = 0; i < nCount; i++) {
            String[] tokens = sc.nextLine().split(" ");
            grades[i] = new Grade();
            grades[i].kor = Integer.parseInt(tokens[0]);
            grades[i].eng = Integer.parseInt(tokens[1]);
            grades[i].math = Integer.parseInt(tokens[2]);
            grades[i].total = grades[i].kor + grades[i].eng + grades[i].math;
            grades[i].average = Math.round(grades[i].total / 3.0f);
        }

        for (Grade g : grades) {
            writer.write(String.format("%d %d %d %d %.1f", g.kor, g.eng, g.math, g.total, g.average));
            writer.newLine();
        }

        writer.close();
    }
}
```


## 💻 C++로 구현
```cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <iomanip>

struct Grade {
    int kor, eng, math, total;
    float average;
};

int main() {
    int nCount;
    std::cout << "학생 수 입력: ";
    std::cin >> nCount;
    std::cin.ignore();

    std::vector<Grade> grades(nCount);
    std::ofstream out("test.txt");
    out << "학생수: " << nCount << "\n";

    for (int i = 0; i < nCount; ++i) {
        std::string line;
        std::getline(std::cin, line);
        std::istringstream iss(line);
        iss >> grades[i].kor >> grades[i].eng >> grades[i].math;
        grades[i].total = grades[i].kor + grades[i].eng + grades[i].math;
        grades[i].average = std::round(grades[i].total / 3.0f);
    }

    for (const auto& g : grades) {
        out << g.kor << " " << g.eng << " " << g.math << " "
            << g.total << " " << std::fixed << std::setprecision(1) << g.average << "\n";
    }

    out.close();
}
```


## 📊 비교 요약 (Markdown)
| 기능             | C#                          | Java                        | C++                          |
|------------------|-----------------------------|-----------------------------|------------------------------|
| 문자열 분할      | `Split(' ')`                | `split(" ")`                | `istringstream`              |
| 숫자 파싱        | `int.Parse()`               | `Integer.parseInt()`        | `>>` 연산자                  |
| 평균 계산        | `/ 3.0f` + `Math.Round()`   | `/ 3.0f` + `Math.round()`   | `/ 3.0f` + `std::round()`    |
| 파일 출력        | `StreamWriter`              | `BufferedWriter`            | `ofstream`                   |

---


## 📐 예제 입력 (고정폭 기준)
```
GRID*   1                               1.27000e-01     0.00000e+00     *        
*       0.00000e+00

```

### 편의상 한줄로 합쳐서 하는 것으로 함:

```
GRID*   1                               1.27000e-01     0.00000e+00     0.00000e+00
```

그리고 각 필드는 다음 위치에 있다고 가정합니다 물론 Coordinate ID가 빠져 있는데 그것도 :
| 필드 이름 | 시작 위치 (0-based) | 길이 | 설명         |
|-----------|---------------------|------|--------------|
| ID        | 8                   | 8    | GRID 번호         |
| CRD ID    | 8                   | 8    | Coordinate 번호    |
| X         | 40                  | 16   | X 좌표         |
| Y         | 56                  | 16   | Y 좌표         |
| Z         | 72                  | 16   | Z 좌표          |


### 💡 C# (고정폭 방식)
```csharp
using System;

struct GRID
{
    public int ID;
    public int CrdID
    public float X, Y, Z;
}

class Program
{
    static void Main()
    {
        string line1 = "GRID*   1                               1.27000e-01     0.00000e+00     *";
        string line2 = "*       0.00000e+00";

        string merged = line1.Replace("*", "").PadRight(80) + line2.Replace("*", "").PadRight(16);

        GRID grid = new GRID();
        grid.ID = int.Parse(merged.Substring(8, 8).Trim());
        grid.CrdID = int.Parse(merged.Substring(16, 8).Trim());
        grid.X = float.Parse(merged.Substring(40, 16).Trim());
        grid.Y = float.Parse(merged.Substring(56, 16).Trim());
        grid.Z = float.Parse(merged.Substring(72, 16).Trim());

        Console.WriteLine($"ID: {grid.ID}, X: {grid.X}, Y: {grid.Y}, Z: {grid.Z}");
    }
}
```

### ☕ Java (고정폭 방식)
```java
public class GridFixedWidth {
    static class GRID {
        int ID;
        int CrdID;
        float X, Y, Z;
    }

    public static void main(String[] args) {
        String line1 = "GRID*   1                               1.27000e-01     0.00000e+00     *";
        String line2 = "*       0.00000e+00";

        String merged = line1.replace("*", "").concat(" ").concat(line2.replace("*", "")).concat("                ");

        GRID grid = new GRID();
        grid.ID = Integer.parseInt(merged.substring(8, 16).trim());
        grid.CrdID = Integer.parseInt(merged.substring(16, 24).trim());
        grid.X = Float.parseFloat(merged.substring(40, 56).trim());
        grid.Y = Float.parseFloat(merged.substring(56, 72).trim());
        grid.Z = Float.parseFloat(merged.substring(72, 88).trim());

        System.out.printf("ID: %d, X: %.5f, Y: %.5f, Z: %.5f%n", grid.ID, grid.X, grid.Y, grid.Z);
    }
}
```

### 💻 C++ (고정폭 방식)
```cpp
#include <iostream>
#include <string>
#include <iomanip>

struct GRID {
    int ID;
    int CrdID;
    float X, Y, Z;
};

std::string trim(const std::string& s) {
    size_t start = s.find_first_not_of(" ");
    size_t end = s.find_last_not_of(" ");
    return (start == std::string::npos) ? "" : s.substr(start, end - start + 1);
}

int main() {
    std::string line1 = "GRID*   1                               1.27000e-01     0.00000e+00     *";
    std::string line2 = "*       0.00000e+00";

    std::string merged = line1;
    merged.erase(std::remove(merged.begin(), merged.end(), '*'), merged.end());
    merged += line2.substr(1); // remove '*'

    GRID grid;
    grid.ID = std::stoi(trim(merged.substr(8, 8)));
    rid.ID = std::stoi(trim(merged.substr(16, 8)));
    grid.X = std::stof(trim(merged.substr(40, 16)));
    grid.Y = std::stof(trim(merged.substr(56, 16)));
    grid.Z = std::stof(trim(merged.substr(72, 16)));

    std::cout << std::fixed << std::setprecision(5);
    std::cout << "ID: " << grid.ID << ", X: " << grid.X << ", Y: " << grid.Y << ", Z: " << grid.Z << std::endl;
}
```


### ✅ 마무리 요약
| 방식         | 장점                                      | 단점                              | 추천 상황                         |
|--------------|-------------------------------------------|-----------------------------------|-----------------------------------|
| `Split()`    | 간단하고 빠르게 구현 가능                 | 공백이 불규칙하거나 없으면 깨짐   | 테스트용, 간단한 입력              |
| `Substring()`| 고정폭 포맷에 강함, 위치 기반으로 안정적 | 칸 위치를 정확히 알아야 함        | NASTRAN, FORTRAN 기반 포맷에 적합 |
---


