## Point4D

```csharp
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;

namespace Geometry
{
  [Serializable]
  [DebuggerDisplay("({X}, {Y}, {Z}, {W})")]
  public class Point4D : Point3D, IEquatable<Point4D>
  {
    #region Ctors

    public Point4D() { }

    public Point4D(double x, double y) : base(x, y)
    {
      W = 1.0;
    }

    public Point4D(double x, double y, double z) : base(x, y, z)
    {
      W = 1.0;
    }

    public Point4D(double x, double y, double z, double w) : base(x, y, z)
    {
      W = w;
    }

    public Point4D(double[] coords) : base(coords)
    {
      if (coords == null || coords.Length < 4)
        throw new ArgumentException("coords must contain at least four elements (x, y, z, w).");
      W = coords[3];
    }

    public Point4D(Point3D p3) : base(p3.X, p3.Y, p3.Z)
    {
      W = 1.0;
    }

    protected Point4D(Point4D other)
    {
      X = other.X; Y = other.Y; Z = other.Z; W = other.W;
    }

    #endregion

    #region Properties

    public double W { get; set; }

    public override bool IsValid()
      => !double.IsNaN(X) && !double.IsNaN(Y) && !double.IsNaN(Z) && !double.IsNaN(W);

    public override double MaximumCoordinate
    {
      get
      {
        double max = base.MaximumCoordinate;
        double absW = Math.Abs(W);
        if (absW > max) max = absW;
        return max;
      }
    }

    /// <summary>
    /// 동차 좌표를 유클리드 좌표로 변환/설정.
    /// W가 0에 매우 가까우면(프로젝티브 무한원) 분모 폭주를 피하기 위해 W=1 가정으로 반환합니다.
    /// </summary>
    public Point3D Euclid
    {
      get
      {
        const double eps = 1e-15;
        double w = Math.Abs(W) < eps ? 1.0 : W;
        return new Point3D(X / w, Y / w, Z / w);
      }
      set
      {
        X = value.X * W;
        Y = value.Y * W;
        Z = value.Z * W;
      }
    }

    #endregion

    #region Object / Equality

    public override object Clone() => new Point4D(this);

    public override double[] ToArray() => new[] { X, Y, Z, W };

    public bool Equals(Point4D other)
    {
      if (ReferenceEquals(other, null)) return false;
      return base.Equals((Point3D)other) && Utility.Compare(other.W, W) == 0;
    }

    public override bool Equals(object obj) => obj is Point4D p && Equals(p);

    public override int GetHashCode() => base.GetHashCode() * 397 ^ W.GetHashCode();

    public static bool operator ==(Point4D left, Point4D right) => Equals(left, right);
    public static bool operator !=(Point4D left, Point4D right) => !Equals(left, right);

    public override string ToString()
      => string.Create(CultureInfo.InvariantCulture, $"Point4D({X}, {Y}, {Z}, {W})");

    #endregion

    #region Operators

    public static Point4D operator +(Point4D a, Point4D b)
      => new Point4D(a.X + b.X, a.Y + b.Y, a.Z + b.Z, a.W + b.W);

    public static Point4D operator -(Point4D a, Point4D b)
      => new Point4D(a.X - b.X, a.Y - b.Y, a.Z - b.Z, a.W - b.W);

    public static Point4D operator *(double s, Point4D p)
      => new Point4D(s * p.X, s * p.Y, s * p.Z, s * p.W);

    public static Point4D operator /(Point4D p, double s)
    {
      double inv = 1.0 / s;
      return new Point4D(p.X * inv, p.Y * inv, p.Z * inv, p.W * inv);
    }

    public static double Distance(Point4D a, Point4D b)
    {
      double dx = b.X - a.X;
      double dy = b.Y - a.Y;
      double dz = b.Z - a.Z;
      double dw = b.W - a.W;
      return Math.Sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
    }

    #endregion

    #region Transform

    public override void TransformBy(Transformation xform)
    {
      var v = xform.ActOnLeft(X, Y, Z, W);
      X = v[0]; Y = v[1]; Z = v[2]; W = v[3];
    }

    #endregion
  }
}
```