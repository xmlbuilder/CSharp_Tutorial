# Plane
```csharp
using System;

namespace Geometry
{
  [Serializable]
  public class Plane : ICloneable
  {
    public enum planeIntersectionType
    {
      Disjoint,
      Coincide,
      UniqueLine,
    }

    // ===== Private fields =====
    private Point3D   _origin;
    private Vector3D  _xAxis;
    private Vector3D  _yAxis;
    private Vector3D  _zAxis;
    private PlaneEquation _equation = new PlaneEquation();

    // ===== Ctors =====
    public Plane()
    {
      _origin = Point3D.Origin;
      _xAxis  = Vector3D.AxisX;
      _yAxis  = Vector3D.AxisY;
      _zAxis  = Vector3D.AxisZ;

      _equation.X = _equation.Y = _equation.D = 0.0;
      _equation.Z = 1.0;
    }

    public Plane(Point3D origin, Vector3D normal)
    {
      if (!SetOriginNormal((Point3D)origin.Clone(), (Vector3D)normal.Clone()))
        throw new ArgumentException("Invalid Plane");
    }

    public Plane(Vector3D normal)
    {
      if (!SetOriginNormal(Point3D.Origin, (Vector3D)normal.Clone()))
        throw new ArgumentException("Invalid Plane");
    }

    public Plane(Point3D origin, Vector3D xAxis, Vector3D yAxis)
    {
      if (!SetOriginXYVector((Point3D)origin.Clone(), (Vector3D)xAxis.Clone(), yAxis))
        throw new ArgumentException("Invalid Plane");
    }

    protected Plane(Plane other)
    {
      SetOriginXYVector((Point3D)other._origin.Clone(), (Vector3D)other._xAxis.Clone(), other._yAxis);
    }

    public Plane(Point3D p, Point3D q, Point3D r) => CreateFromPoints(p, q, r);

    public Plane(double[] coefficients)
    {
      if (!SetPlaneEquation(coefficients))
        throw new ArgumentException("Invalid Plane");
    }

    public virtual object Clone() => new Plane(this);

    // ===== Core builders =====
    internal bool SetOriginNormal(Point3D origin, Vector3D normal)
    {
      _origin = origin;
      _zAxis  = normal;

      bool ok = _zAxis.Normalize();
      _xAxis  = Vector3D.AxisX;
      _xAxis.PerpendicularTo(_zAxis);
      _xAxis.Normalize();

      _yAxis = Vector3D.Cross(_zAxis, _xAxis);
      _yAxis.Normalize();

      UpdateEquation();
      return ok;
    }

    private bool SetOriginXYVector(Point3D origin, Vector3D xAxis, Vector3D yAxis)
    {
      _origin = origin;

      _xAxis = xAxis;
      _xAxis.Normalize();

      // remove x component from incoming y, then normalize
      _yAxis = yAxis - Vector3D.Dot(yAxis, _xAxis) * _xAxis;
      _yAxis.Normalize();

      _zAxis = Vector3D.Cross(_xAxis, _yAxis);
      bool ok = _zAxis.Normalize();

      UpdateEquation();
      return ok;
    }

    public bool CreateFromPoints(Point3D p, Point3D q, Point3D r)
    {
      _origin = p;
      _zAxis  = new Vector3D(p, q, r);
      bool ok = !_zAxis.IsZero;

      _xAxis = Vector3D.Subtract(q, p);
      _xAxis.Normalize();

      _yAxis = Vector3D.Cross(_zAxis, _xAxis);
      _yAxis.Normalize();

      if (!_equation.Create(_origin, _zAxis))
        ok = false;

      return ok;
    }

    private bool SetPlaneEquation(double[] coeffs)
    {
      bool ok = false;

      _equation = new PlaneEquation
      {
        X = coeffs[0],
        Y = coeffs[1],
        Z = coeffs[2],
        D = coeffs[3]
      };

      _zAxis = new Vector3D(coeffs[0], coeffs[1], coeffs[2]);
      double len = _zAxis.Length;
      _zAxis.Normalize();

      if (len > 0.0)
      {
        // origin is closest point on plane to world origin
        _origin = -(1.0 / len) * _equation.D * _zAxis.AsPoint;
        ok = true;
      }

      _xAxis = new Vector3D();
      _xAxis.PerpendicularTo(_zAxis);
      _xAxis.Normalize();

      _yAxis = Vector3D.Cross(_zAxis, _xAxis);
      _yAxis.Normalize();

      return ok;
    }

    public void UpdateEquation() => _equation = new PlaneEquation(_origin, _zAxis);

    // ===== Geometry ops =====
    public Point3D Reflect(Point3D point)
    {
      double dist = DistanceTo(point);
      return new Point3D((PointAt(Project(point)) - dist * _zAxis).ToArray());
    }

    public Vector3D Reflect(Vector3D vector)
    {
      // Reflect vector end-point about plane through origin with same normal
      return new Vector3D(new Plane(_zAxis).Reflect(new Point3D(vector.ToArray())).ToArray());
    }

    public bool IsValid()
    {
      if (!_equation.IsValid())
        return false;

      double evalAtOrigin = _equation.ValueAt(_origin);
      if (Math.Abs(evalAtOrigin) > 1E-12)
      {
        double scale = Math.Abs(_origin.MaximumCoordinate) + Math.Abs(_equation.D);
        if (scale <= 1000.0 || !_origin.IsValid())
          return false;

        double tol = scale * 2.220446049250313E-15;
        if (Math.Abs(evalAtOrigin) > tol)
          return false;
      }

      if (!ValidateAxesRightHandedUnit(_xAxis, _yAxis, _zAxis))
        return false;

      Vector3D n = new Vector3D(_equation.X, _equation.Y, _equation.Z);
      n.Normalize();

      return Math.Abs(Vector3D.Dot(n, _zAxis) - 1.0) <= 1.490116119385E-08;
    }

    // (1) Check: valid, non-zero, near-orthogonal triplet
    private bool CheckXYZValidate(Vector3D x, Vector3D y, Vector3D z)
    {
      if (!x.IsValid() || !y.IsValid() || !z.IsValid())
        return false;

      double lx = x.Length, ly = y.Length, lz = z.Length;
      if (lx <= 1.490116119385E-08 || ly <= 1.490116119385E-08 || lz <= 1.490116119385E-08)
        return false;

      double invX = 1.0 / lx, invY = 1.0 / ly, invZ = 1.0 / lz;
      double dotXY = (x.X * y.X + x.Y * y.Y + x.Z * y.Z) * invX * invY;
      double dotYZ = (y.X * z.X + y.Y * z.Y + y.Z * z.Z) * invY * invZ;
      double dotZX = (z.X * x.X + z.Y * x.Y + z.Z * x.Z) * invZ * invX;

      if (Math.Abs(dotXY) > 1.490116119385E-08 ||
          Math.Abs(dotYZ) > 1.490116119385E-08 ||
          Math.Abs(dotZX) > 1.490116119385E-08)
      {
        // allow very small non-orthogonality, then verify right-handedness tightly
        const double loose = 1.52587890625E-05;
        if (Math.Abs(dotXY) >= loose || Math.Abs(dotYZ) >= loose || Math.Abs(dotZX) >= loose)
          return false;

        Vector3D cx = invX * invY * Vector3D.Cross(x, y);
        if (Math.Abs(Math.Abs((cx.X * z.X + cx.Y * z.Y + cx.Z * z.Z) * invZ) - 1.0) > 1.490116119385E-08)
          return false;

        Vector3D cy = invY * invZ * Vector3D.Cross(y, z);
        if (Math.Abs(Math.Abs((cy.X * x.X + cy.Y * x.Y + cy.Z * x.Z) * invX) - 1.0) > 1.490116119385E-08)
          return false;

        Vector3D cz = invZ * invX * Vector3D.Cross(z, x);
        if (Math.Abs(Math.Abs((cz.X * y.X + cz.Y * y.Y + cz.Z * y.Z) * invY) - 1.0) > 1.490116119385E-08)
          return false;
      }

      return true;
    }

    // (2) Check: unit-length & orthogonal
    private bool CheckXYZAxis(Vector3D x, Vector3D y, Vector3D z)
    {
      return CheckXYZValidate(x, y, z)
          && Math.Abs(x.Length - 1.0) <= 1.490116119385E-08
          && Math.Abs(y.Length - 1.0) <= 1.490116119385E-08
          && Math.Abs(z.Length - 1.0) <= 1.490116119385E-08;
    }

    // (3) Check: right-handed
    private bool ValidateAxesRightHandedUnit(Vector3D x, Vector3D y, Vector3D z)
    {
      return CheckXYZAxis(x, y, z) && Vector3D.Dot(Vector3D.Cross(x, y), z) > 1.490116119385E-08;
    }

    // ===== Evaluation / projection =====
    public Point3D PointAt(Point2D uv) => PointAt(uv.X, uv.Y);

    public Point3D PointAt(double s, double t) => _origin + s * _xAxis + t * _yAxis;

    public Point3D PointAt(double s, double t, double c)
    {
      return _origin + s * _xAxis + t * _yAxis + c * _zAxis;
    }

    // ===== Intersections =====
    public static planeIntersectionType Intersection(Plane a, Plane b, out Segment3D line)
    {
      Point3D point;
      Vector3D direction;
      int kind = (int)Plane.Intersection(a, b, 1E-12, out point, out direction);
      line = new Segment3D(point, point + direction);
      return (planeIntersectionType)kind;
    }

    public static planeIntersectionType Intersection(Plane a, Plane b, double tol, out Segment3D line)
    {
      Point3D point;
      Vector3D direction;
      int kind = (int)Plane.Intersection(a, b, tol, out point, out direction);
      line = new Segment3D(point, point + direction);
      return (planeIntersectionType)kind;
    }

    public static planeIntersectionType Intersection(Plane a, Plane b, double tol, out Point3D point, out Vector3D direction)
    {
      point = new Point3D();
      direction = Vector3D.Cross(a.AxisZ, b.AxisZ);

      double ax = direction.X >= 0.0 ? direction.X : -direction.X;
      double ay = direction.Y >= 0.0 ? direction.Y : -direction.Y;
      double az = direction.Z >= 0.0 ? direction.Z : -direction.Z;

      if (ax + ay + az < 1E-09)
      {
        Vector3D deltaOrigin = Vector3D.Subtract(b.Origin, a.Origin);
        return Utility.Compare(tol, a.AxisZ * deltaOrigin, 0.0) == 0
          ? planeIntersectionType.Coincide
          : planeIntersectionType.Disjoint;
      }

      // project to most stable coordinate plane
      int maxAxis = ax <= ay ? (ay <= az ? 3 : 2) : (ax <= az ? 3 : 1);
      double da = -Vector3D.Dot(a.AxisZ, a.Origin);
      double db = -Vector3D.Dot(b.AxisZ, b.Origin);

      switch (maxAxis)
      {
        case 1: // X dominant
          point.X = 0.0;
          point.Y = (db * a.AxisZ.Z - da * b.AxisZ.Z) / direction.X;
          point.Z = (da * b.AxisZ.Y - db * a.AxisZ.Y) / direction.X;
          break;
        case 2: // Y dominant
          point.X = (da * b.AxisZ.Z - db * a.AxisZ.Z) / direction.Y;
          point.Y = 0.0;
          point.Z = (db * a.AxisZ.X - da * b.AxisZ.X) / direction.Y;
          break;
        case 3: // Z dominant
          point.X = (db * a.AxisZ.Y - da * b.AxisZ.Y) / direction.Z;
          point.Y = (da * b.AxisZ.X - db * a.AxisZ.X) / direction.Z;
          point.Z = 0.0;
          break;
      }

      return planeIntersectionType.UniqueLine;
    }

    // ===== Transforms =====
    public void TransformBy(Transformation transform)
    {
      Point3D newOrigin = transform * _origin;
      Vector3D newX = Vector3D.Subtract(transform * (_origin + _xAxis), newOrigin);
      Vector3D newY = Vector3D.Subtract(transform * (_origin + _yAxis), newOrigin);
      SetOriginXYVector(newOrigin, newX, newY);
    }

    public Plane Offset(double distance)
    {
      var copy = new Plane(this);
      copy.Origin += _zAxis * distance;
      return copy;
    }

    internal void Transform(double sinAngle, double cosAngle, Vector3D axis)
    {
      if (Vector3D.AreCoincident(axis, _zAxis))
      {
        Vector3D newX = cosAngle * _xAxis + sinAngle * _yAxis;
        Vector3D newY = cosAngle * _yAxis - sinAngle * _xAxis;
        _xAxis = newX;
        _yAxis = newY;
      }
      else
      {
        Point3D savedOrigin = _origin;
        Transform(sinAngle, cosAngle, axis, _origin);
        _origin = savedOrigin;
      }
    }

    internal void Transform(double sinAngle, double cosAngle, Vector3D axis, Point3D center)
    {
      Transformation t = new Transformation();
      if (center == _origin)
      {
        t.UpdateMatrix(sinAngle, cosAngle, axis, Point3D.Origin);
        _xAxis = t * _xAxis;
        _yAxis = t * _yAxis;
        _zAxis = t * _zAxis;
        UpdateEquation();
      }
      else
      {
        t.UpdateMatrix(sinAngle, cosAngle, axis, center);
        TransformBy(t);
      }
    }

    public void Rotate(double angleInRadians, Vector3D axis)
    {
      Rotate(angleInRadians, axis, Point3D.Origin);
    }

    public void Rotate(double angleInRadians, Vector3D axis, Point3D center)
    {
      Transform(Math.Sin(angleInRadians), Math.Cos(angleInRadians), axis, center);
    }

    public void Translate(double dx, double dy, double dz = 0.0)
    {
      Transformation t = new Transformation();
      t.Translation(dx, dy, dz);
      TransformBy(t);
    }

    public void Translate(Vector3D delta)
    {
      Transformation t = new Transformation();
      t.Translation(delta);
      TransformBy(t);
    }

    // ===== Canonical planes =====
    public static Plane XY => new Plane();
    public static Plane YX => new Plane(Point3D.Origin, Vector3D.AxisY, Vector3D.AxisX);
    public static Plane YZ => new Plane(Point3D.Origin, Vector3D.AxisY, Vector3D.AxisZ);
    public static Plane ZY => new Plane(Point3D.Origin, Vector3D.AxisZ, Vector3D.AxisY);
    public static Plane ZX => new Plane(Point3D.Origin, Vector3D.AxisZ, Vector3D.AxisX);
    public static Plane XZ => new Plane(Point3D.Origin, Vector3D.AxisX, Vector3D.AxisZ);

    // ===== Metrics / projections =====
    public double DistanceTo(Point3D point) => Vector3D.Dot(point - _origin, _zAxis);

    public bool Flip()
    {
      Vector3D oldX = _xAxis;
      _xAxis = _yAxis;
      _yAxis = oldX;
      _zAxis.Negate();
      UpdateEquation();
      return true;
    }

    public void Project(Point3D p, out double s, out double t)
    {
      Vector3D v = Vector3D.Subtract(p, _origin);
      s = v * _xAxis;
      t = v * _yAxis;
    }

    public Point2D Project(Point3D p)
    {
      Project(p, out double s, out double t);
      return new Point2D(s, t);
    }

    public Vector2D Project(Vector3D v)
    {
      Project(v.AsPoint, out double s, out double t);
      return new Vector2D(s, t);
    }

    // ===== Properties =====
    public Point3D Origin
    {
      get => _origin;
      set { _origin = value; UpdateEquation(); }
    }

    public Vector3D AxisX => _xAxis;
    public Vector3D AxisY => _yAxis;

    public Vector3D AxisZ
    {
      get => _zAxis;
      set
      {
        _zAxis = value;
        if (!SetOriginNormal((Point3D)Origin.Clone(), (Vector3D)value.Clone()))
          throw new ArgumentException("Invalid ZAxis");
      }
    }

    public PlaneEquation Equation => _equation;

    // ===== Equality / hashing / debug =====
    public override string ToString()
    {
      return $"Origin: {_origin}  Z Axis: {_zAxis}";
    }

    public bool Equals(Plane other)
    {
      if ((object)other == null) return false;
      if ((object)this == (object)other) return true;

      return object.Equals(other._zAxis, _zAxis)
          && object.Equals(other._yAxis, _yAxis)
          && object.Equals(other._xAxis, _xAxis)
          && object.Equals(other._origin, _origin);
    }

    public override bool Equals(object obj)
    {
      if (obj == null) return false;
      if ((object)this == obj) return true;
      return obj is Plane p && Equals(p);
    }

    public override int GetHashCode()
    {
      unchecked
      {
        int h = 17;
        h = h * 397 ^ (_zAxis  != (Vector3D)null ? _zAxis.GetHashCode()  : 0);
        h = h * 397 ^ (_yAxis  != (Vector3D)null ? _yAxis.GetHashCode()  : 0);
        h = h * 397 ^ (_xAxis  != (Vector3D)null ? _xAxis.GetHashCode()  : 0);
        h = h * 397 ^ (_origin != (Point3D) null ? _origin.GetHashCode() : 0);
        return h;
      }
    }

    public static bool operator ==(Plane left, Plane right)  => object.Equals(left, right);
    public static bool operator !=(Plane left, Plane right)  => !object.Equals(left, right);
  }
}
```