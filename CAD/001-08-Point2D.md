## Point2D
```csharp
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Xml.Linq;

namespace Geometry
{
  [Serializable]
  [DebuggerDisplay("({X}, {Y})")]
  public class Point2D : ICloneable, IEquatable<Point2D>
  {
    public double X;
    public double Y;

    #region Constructors

    public Point2D() { }

    public Point2D(double x, double y)
    {
      X = x; Y = y;
    }

    public Point2D(double[] coords)
    {
      if (coords == null || coords.Length < 2)
        throw new ArgumentException("coords must contain at least two elements (x,y).");
      X = coords[0];
      Y = coords[1];
    }

    protected Point2D(Point2D other)
    {
      X = other.X;
      Y = other.Y;
    }

    #endregion

    #region Factory & Constants

    public static Point2D Origin   => new Point2D(0.0, 0.0);
    public static Point2D MinValue => new Point2D(double.MinValue, double.MinValue);
    public static Point2D MaxValue => new Point2D(double.MaxValue, double.MaxValue);

    #endregion

    #region Basic

    public virtual object Clone() => new Point2D(this);

    public virtual double[] ToArray() => new[] { X, Y };

    public virtual bool IsValid() => !double.IsNaN(X) && !double.IsNaN(Y);

    [Browsable(false)]
    public virtual double MaximumCoordinate
    {
      get
      {
        double max = Math.Abs(X);
        if (Math.Abs(Y) > max) max = Math.Abs(Y);
        return max;
      }
    }

    [Browsable(false)]
    public Vector2D AsVector => new Vector2D(X, Y);

    #endregion

    #region Operators

    public static Point2D operator +(Point2D a, Point2D b) => new Point2D(a.X + b.X, a.Y + b.Y);
    public static Point2D operator +(Point2D p, Vector2D v) => new Point2D(p.X + v.X, p.Y + v.Y);
    public static Point2D operator +(Vector2D v, Point2D p) => new Point2D(v.X + p.X, v.Y + p.Y);

    public static Point2D operator -(Point2D a, Point2D b) => new Point2D(a.X - b.X, a.Y - b.Y);
    public static Point2D operator -(Point2D p, Vector2D v) => new Point2D(p.X - v.X, p.Y - v.Y);
    public static Point2D operator -(Vector2D v, Point2D p) => new Point2D(v.X - p.X, v.Y - p.Y);

    public static Point2D operator *(double s, Point2D p) => new Point2D(s * p.X, s * p.Y);
    public static Point2D operator *(Point2D p, double s) => new Point2D(s * p.X, s * p.Y);
    public static Point2D operator /(Point2D p, double s) => new Point2D(p.X / s, p.Y / s);

    public static bool operator ==(Point2D left, Point2D right) => Equals(left, right);
    public static bool operator !=(Point2D left, Point2D right) => !Equals(left, right);

    #endregion

    #region Geometry helpers

    /// <summary>
    /// 선분(seg) 위로 수직 사영된 점을 반환합니다. (클램핑 없음: 무한 직선상 사영값)
    /// </summary>
    public Point2D ProjectTo(Segment2D seg)
    {
      var dir = new Vector2D(seg.P1.X - seg.P0.X, seg.P1.Y - seg.P0.Y);
      var ap  = new Vector2D(X - seg.P0.X, Y - seg.P0.Y);

      double len2 = dir.X * dir.X + dir.Y * dir.Y;
      double t    = len2 < 1e-9 ? 0.0 : (Vector2D.Dot(dir, ap) / len2);

      return new Point2D(seg.P0.X + t * dir.X, seg.P0.Y + t * dir.Y);
    }

    public double DistanceTo(Segment2D seg) => DistanceTo(ProjectTo(seg));

    public static Point2D MidPoint(Point2D a, Point2D b) => new Point2D((a.X + b.X) * 0.5, (a.Y + b.Y) * 0.5);

    public static double Distance(Point2D a, Point2D b)
    {
      double dx = b.X - a.X;
      double dy = b.Y - a.Y;
      return Math.Sqrt(dx * dx + dy * dy);
    }

    public static double DistanceSquared(Point2D a, Point2D b)
    {
      double dx = b.X - a.X;
      double dy = b.Y - a.Y;
      return dx * dx + dy * dy;
    }

    public double DistanceTo(Point2D other) => Distance(this, other);

    /// <summary>
    /// 도메인 크기 대비 상대 오차로 두 점 비교(원본 로직 유지).
    /// </summary>
    public static bool AreEqual(Point2D p1, Point2D p2, double domainSize)
    {
      return Distance(p1, p2) / domainSize < 1e-9;
    }

    public virtual void TransformBy(Transformation xform)
    {
      var v = xform.ActOnLeft(X, Y, 0.0, 1.0);
      double wInv = v[3] != 0.0 ? 1.0 / v[3] : 1.0;
      X = wInv * v[0];
      Y = wInv * v[1];
    }

    #endregion

    #region Equality & Hashing

    public bool Equals(Point2D other)
    {
      if (ReferenceEquals(other, null)) return false;
      // 기존 코드 호환: Utility.Compare 사용
      return Utility.Compare(other.X, X) == 0 && Utility.Compare(other.Y, Y) == 0;
    }

    public override bool Equals(object obj) => obj is Point2D p && Equals(p);

    public override int GetHashCode() => X.GetHashCode() * 397 ^ Y.GetHashCode();

    #endregion

  }
}
```