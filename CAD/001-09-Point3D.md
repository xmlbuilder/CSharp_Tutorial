## Point3D
```csharp
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;

namespace Geometry
{
  [Serializable]
  [DebuggerDisplay("({X}, {Y}, {Z})")]
  public class Point3D : Point2D, IEquatable<Point3D>
  {
    public double Z;

    #region Constructors

    public Point3D() { }

    public Point3D(double x, double y) : base(x, y)
    {
      Z = 0.0;
    }

    public Point3D(double x, double y, double z) : base(x, y)
    {
      Z = z;
    }

    public Point3D(double[] coords) : base(coords)
    {
      if (coords == null || coords.Length < 3)
        throw new ArgumentException("coords must contain at least three elements (x, y, z).");
      Z = coords[2];
    }

    protected Point3D(Point3D other) : base(other)
    {
      Z = other.Z;
    }

    #endregion

    #region Factories

    public static Point3D Origin   => new Point3D(0.0, 0.0, 0.0);
    public static Point3D MinValue => new Point3D(double.MinValue, double.MinValue, double.MinValue);
    public static Point3D MaxValue => new Point3D(double.MaxValue, double.MaxValue, double.MaxValue);

    #endregion

    #region Basic

    public override object Clone() => new Point3D(this);

    public override double[] ToArray() => new[] { X, Y, Z };

    public override bool IsValid() => base.IsValid() && !double.IsNaN(Z);

    public bool IsInside(Point3D boxMin, Point3D boxMax)
    {
      return boxMin.X < X && X < boxMax.X &&
             boxMin.Y < Y && Y < boxMax.Y &&
             boxMin.Z < Z && Z < boxMax.Z;
    }

    [Browsable(false)]
    public Vector3D AsVector => new Vector3D(X, Y, Z);

    public override double MaximumCoordinate
    {
      get
      {
        double max = base.MaximumCoordinate;
        double absZ = Math.Abs(Z);
        if (absZ > max) max = absZ;
        return max;
      }
    }

    #endregion

    #region Geometry helpers

    public static Point3D MidPoint(Point3D a, Point3D b)
      => new Point3D((a.X + b.X) * 0.5, (a.Y + b.Y) * 0.5, (a.Z + b.Z) * 0.5);

    public double DistanceTo(Point3D other) => Distance(this, other);

    public static double Distance(Point3D a, Point3D b)
    {
      double dx = b.X - a.X;
      double dy = b.Y - a.Y;
      double dz = b.Z - a.Z;
      return Math.Sqrt(dx * dx + dy * dy + dz * dz);
    }

    public static double DistanceSquared(Point3D a, Point3D b)
    {
      double dx = b.X - a.X;
      double dy = b.Y - a.Y;
      double dz = b.Z - a.Z;
      return dx * dx + dy * dy + dz * dz;
    }

    public Point3D ProjectTo(Segment3D seg)
    {
      var dir = Vector3D.Subtract(seg.P1, seg.P0);
      var ap  = Vector3D.Subtract(this,  seg.P0);
      double len2 = dir.LengthSquared;
      double t = len2 < 2.220446049250313E-16 ? 0.0 : Vector3D.Dot(dir, ap) / len2;
      return seg.P0 + t * dir;
    }

    public double DistanceTo(Segment3D seg) => DistanceTo(ProjectTo(seg));

    public double DistanceTo(Plane plane) => plane.DistanceTo(this);

    public static bool AreEqual(Point3D p1, Point3D p2, double domainSize)
      => Distance(p1, p2) / domainSize < 1e-9;

    #endregion

    #region Equality & Hashing

    public bool Equals(Point3D other)
    {
      if (ReferenceEquals(other, null)) return false;
      return base.Equals((Point2D)other) && Utility.Compare(other.Z, Z) == 0;
    }

    public override bool Equals(object obj) => obj is Point3D p && Equals(p);

    public override int GetHashCode() => base.GetHashCode() * 397 ^ Z.GetHashCode();

    public static bool operator ==(Point3D left, Point3D right) => Equals(left, right);
    public static bool operator !=(Point3D left, Point3D right) => !Equals(left, right);

    #endregion

    #region Operators

    public static Point3D operator +(Point3D a, Point3D b) => new Point3D(a.X + b.X, a.Y + b.Y, a.Z + b.Z);
    public static Point3D operator -(Point3D a, Point3D b) => new Point3D(a.X - b.X, a.Y - b.Y, a.Z - b.Z);

    public static Point3D operator +(Point3D p, Vector3D v) => new Point3D(p.X + v.X, p.Y + v.Y, p.Z + v.Z);
    public static Point3D operator +(Vector3D v, Point3D p) => new Point3D(v.X + p.X, v.Y + p.Y, v.Z + p.Z);

    public static Point3D operator -(Point3D p, Vector3D v) => new Point3D(p.X - v.X, p.Y - v.Y, p.Z - v.Z);
    public static Point3D operator -(Vector3D v, Point3D p) => new Point3D(v.X - p.X, v.Y - p.Y, v.Z - p.Z);

    public static Point3D operator *(double s, Point3D p) => new Point3D(s * p.X, s * p.Y, s * p.Z);
    public static Point3D operator *(Point3D p, double s) => new Point3D(s * p.X, s * p.Y, s * p.Z);
    public static Point3D operator /(Point3D p, double s) => new Point3D(p.X / s, p.Y / s, p.Z / s);

    #endregion

    #region IO & Formatting

    public override string ToString()
    {
      return string.Create(CultureInfo.InvariantCulture, $"Point3D({X}, {Y}, {Z})");
    }

    public virtual void WriteAsFloat(BinaryWriter bw)
    {
      bw.Write((float)X);
      bw.Write((float)Y);
      bw.Write((float)Z);
    }

    #endregion

    #region Indexer & Transform

    public double this[int index]
    {
      get
      {
        if (index == 0) return X;
        if (index == 1) return Y;
        return Z; // 원본 호환: 범위 밖 요청에도 예외 대신 Z 반환
      }
    }

    public override void TransformBy(Transformation xform)
    {
      var v = xform.ActOnLeft(X, Y, Z, 1.0);
      double wInv = v[3] != 0.0 ? 1.0 / v[3] : 1.0;
      X = wInv * v[0];
      Y = wInv * v[1];
      Z = wInv * v[2];
    }

    #endregion
  }
}
```
