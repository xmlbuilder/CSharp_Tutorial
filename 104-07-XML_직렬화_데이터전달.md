# XML 데이터 전달
이 C# 예제는 Novel 객체 배열을 XML로 직렬화하고 다시 역직렬화하는 과정을 보여주며,  
프로그램 간 데이터 전달의 대표적인 방식 중 하나인 XML 기반 교환을 구현하고 있어요.  
이 구조는 다른 언어에서도 동일하게 구현할 수 있으며, 특히 시스템 간 통신, 파일 기반 데이터 교환, API 응답 포맷 등에서 널리 사용됩니다.


## 🧩 C# 기준: XML 직렬화로 프로그램 간 데이터 전달
```csharp
namespace GrammarTest
{
    public class Program
    {
        public class Novel
        {
            public string Title { get; set; }
            public string Author { get; set; }
            public int Published { get; set; }
            public override string ToString()
            {
                return $"[Title = {Title}, Author={Author}, Published={Published}]";
            }
        }
        
        public static void Main(String[] args)
        {
            Novel[] novels = new[]
            {
                new Novel()
                {
                    Author = "제임스 P. 호건",
                    Title = "별의 계승자",
                    Published = 1977,
                },
                new Novel()
                {
                    Author = "제임스 P. 호건",
                    Title = "별의 계승자",
                    Published = 1977,
                },
            };
            var settings = new XmlWriterSettings()
            {
                Encoding = new System.Text.UTF8Encoding(false),
                Indent = true,
                IndentChars = " "
            };
            
            using (var writer = XmlWriter.Create("/Users/jeongjunghwan/Downloads/SampleTest.xml"))
            {
                var serializer = new XmlSerializer(novels.GetType());
                serializer.Serialize(writer, novels);
            }
            using (var reader = XmlReader.Create("/Users/jeongjunghwan/Downloads/SampleTest.xml"))
            {
                var serializer = new XmlSerializer(typeof(Novel[]));
                var novel1 = serializer.Deserialize(reader) as Novel[];
                foreach (var novel in novel1)
                {
                    Console.WriteLine(novel);   
                }
            }

        }
    }
}


```
- XmlSerializer를 사용해 객체 배열을 XML로 저장
- 다른 프로그램에서 XML을 읽어 동일한 구조로 역직렬화 가능
- 파일, 네트워크, IPC 등 다양한 경로로 전달 가능

## ☕ Java: JAXB 기반 XML 직렬화
```java
import javax.xml.bind.annotation.*;
import javax.xml.bind.*;
import java.io.File;
import java.util.*;

@XmlRootElement(name = "Novels")
class NovelList {
    @XmlElement(name = "Novel")
    public List<Novel> novels = new ArrayList<>();
}

@XmlAccessorType(XmlAccessType.FIELD)
class Novel {
    public String title;
    public String author;
    public int published;

    @Override
    public String toString() {
        return "[Title = " + title + ", Author = " + author + ", Published = " + published + "]";
    }
}

public class XMLTransfer {
    public static void main(String[] args) throws Exception {
        NovelList list = new NovelList();
        list.novels.add(new Novel() {{ title = "별의 계승자"; author = "제임스 P. 호건"; published = 1977; }});
        list.novels.add(new Novel() {{ title = "별의 계승자"; author = "제임스 P. 호건"; published = 1977; }});

        JAXBContext context = JAXBContext.newInstance(NovelList.class);
        Marshaller marshaller = context.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        marshaller.marshal(list, new File("SampleTest.xml")); // 객체 → XML

        NovelList loaded = (NovelList) context.createUnmarshaller().unmarshal(new File("SampleTest.xml")); // XML → 객체
        loaded.novels.forEach(System.out::println);
    }
}

```
Java에서는 JAXB를 통해 XML 기반 데이터 전달이 가능하며, 다른 시스템에서도 쉽게 파싱할 수 있어요.


## 🧱 C++: libxml2
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <libxml/parser.h>
#include <libxml/tree.h>

struct Novel {
    std::string title;
    std::string author;
    int published;
};

void serializeNovels(const std::vector<Novel>& novels, const std::string& filename) {
    xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "Novels");
    xmlDocSetRootElement(doc, root);

    for (const auto& novel : novels) {
        xmlNodePtr novelNode = xmlNewChild(root, nullptr, BAD_CAST "Novel", nullptr);
        xmlNewChild(novelNode, nullptr, BAD_CAST "Title", BAD_CAST novel.title.c_str());
        xmlNewChild(novelNode, nullptr, BAD_CAST "Author", BAD_CAST novel.author.c_str());

        std::string year = std::to_string(novel.published);
        xmlNewChild(novelNode, nullptr, BAD_CAST "Published", BAD_CAST year.c_str());
    }

    xmlSaveFormatFileEnc(filename.c_str(), doc, "UTF-8", 1);
    xmlFreeDoc(doc);
    xmlCleanupParser();
}

std::vector<Novel> deserializeNovels(const std::string& filename) {
    std::vector<Novel> novels;
    xmlDocPtr doc = xmlReadFile(filename.c_str(), nullptr, 0);
    if (!doc) return novels;

    xmlNodePtr root = xmlDocGetRootElement(doc);
    for (xmlNodePtr node = root->children; node; node = node->next) {
        if (node->type == XML_ELEMENT_NODE && xmlStrEqual(node->name, BAD_CAST "Novel")) {
            Novel novel;
            for (xmlNodePtr child = node->children; child; child = child->next) {
                if (child->type != XML_ELEMENT_NODE) continue;

                std::string content = (char*)xmlNodeGetContent(child);
                if (xmlStrEqual(child->name, BAD_CAST "Title")) novel.title = content;
                else if (xmlStrEqual(child->name, BAD_CAST "Author")) novel.author = content;
                else if (xmlStrEqual(child->name, BAD_CAST "Published")) novel.published = std::stoi(content);
            }
            novels.push_back(novel);
        }
    }

    xmlFreeDoc(doc);
    xmlCleanupParser();
    return novels;
}

int main() {
    std::vector<Novel> novels = {
        { "별의 계승자", "제임스 P. 호건", 1977 },
        { "별의 계승자", "제임스 P. 호건", 1977 }
    };

    std::string filename = "SampleTest.xml";
    serializeNovels(novels, filename);

    auto loaded = deserializeNovels(filename);
    for (const auto& n : loaded)
        std::cout << "[Title = " << n.title << ", Author = " << n.author << ", Published = " << n.published << "]\n";
}
```

## 🐍 Python: ElementTree 기반 수동 직렬화
```python
import xml.etree.ElementTree as ET
from dataclasses import dataclass

@dataclass
class Novel:
    title: str
    author: str
    published: int

novels = [
    Novel("별의 계승자", "제임스 P. 호건", 1977),
    Novel("별의 계승자", "제임스 P. 호건", 1977)
]

# 객체 → XML
root = ET.Element("Novels")
for novel in novels:
    elem = ET.SubElement(root, "Novel")
    ET.SubElement(elem, "Title").text = novel.title
    ET.SubElement(elem, "Author").text = novel.author
    ET.SubElement(elem, "Published").text = str(novel.published)

tree = ET.ElementTree(root)
tree.write("SampleTest.xml", encoding="utf-8", xml_declaration=True)

# XML → 객체
tree2 = ET.parse("SampleTest.xml")
root2 = tree2.getroot()
loaded = []
for elem in root2.findall("Novel"):
    loaded.append(Novel(
        title=elem.find("Title").text,
        author=elem.find("Author").text,
        published=int(elem.find("Published").text)
    ))

for n in loaded:
    print(n)
```

Python은 간결한 문법으로 XML을 생성하고 파싱할 수 있으며, 다른 언어와의 데이터 교환에도 적합합니다.


## 🧭 요약 비교
| 언어       | XML 직렬화 방식               | 특징 요약                                               |
|------------|-------------------------------|----------------------------------------------------------|
| **C#**     | `XmlSerializer`               | 자동 직렬화, 속성 기반, 간단한 구조                      |
| **Java**   | `JAXB`                        | 어노테이션 기반, 표준화된 XML 출력                      |
| **C++**    | `Boost.Serialization`         | 고성능, 템플릿 기반 자동 직렬화, 다양한 설정 가능        |
| **Py

---
