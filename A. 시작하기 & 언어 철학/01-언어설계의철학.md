# 인터페이스의 저주와 `default`의 반란  
## — Java 언어 철학의 균열

### 📌 주제 요약
Java는 오랫동안 인터페이스를 순수 추상화 도구로 유지해왔다. 하지만 이 설계는 확장 불가능한 구조를 낳았고, 결국 Java 8에서 `default` 메서드를 도입함으로써 그 철학을 꺾게 된다. 
이 글은 그 배경과 의미를 탐구한다.

---

## 1. 인터페이스의 순수주의

Java 초기 설계에서 `interface`는 **순수 추상화**를 위한 도구였다. 모든 메서드는 구현 없이 선언만 가능했고, 이는 객체지향의 이상을 반영한 구조였다.

```java
public interface MyService {
    void process();
}
```

이런 구조는 다형성과 계약 기반 설계에 유리했지만, 시간이 지나면서 확장 불가능한 구조라는 한계를 드러냈다.

## 2. 확장 불가능한 계약서
인터페이스가 라이브러리나 프레임워크에서 널리 사용되면서, 새로운 기능을 추가하려는 순간 모든 구현체가 깨지는 문제가 발생했다.
```java
public interface MyService {
    void process();
    void validate(); // ❌ 모든 구현 클래스가 컴파일 에러
}
```

- 수백 개의 구현체가 존재할 경우, 기능 하나 추가하는 것이 재앙이 된다.
- 하위 호환성을 중시하는 Java에서는 이런 구조가 언어 진화의 발목을 잡는 요인이 되었다.

## 3. default 메서드의 등장
Java 8에서 드디어 interface에 구현을 허용하는 default 메서드가 도입되었다.
```cpp
public interface MyService {
    void process();

    default void validate() {
        System.out.println("기본 구현");
    }
}
```

이로써:
- 기존 구현체는 깨지지 않음
- 새로운 기능은 점진적으로 확장 가능
- 라이브러리 개발자는 지뢰밭 대신 안전한 길을 만들 수 있게 됨

## 4. 철학의 균열
default 메서드의 도입은 단순한 문법 확장이 아니다.
Java가 자기 철학을 꺾고 현실과 타협한 순간이다.
| 과거 철학 | 변화 이후 | 
|----------|------------|
| 인터페이스는 순수 추상 | 구현을 허용 (default) | 
| 하위 호환성 최우선 | 확장성과 유연성도 고려 | 
| API 확장 어려움 | 점진적 기능 추가 가능 | 



## 5. C++과의 비교: 다른 종류의 지옥
C++은 인터페이스 개념이 명확하지 않지만, 대신 static 초기화 지옥이라는 고유의 문제를 안고 있다.
- 전역 static 객체의 초기화 순서가 컴파일러나 링크 순서에 따라 달라질 수 있음
- 이로 인해 정의되지 않은 동작이나 런타임 오류가 발생할 수 있음
- 아직까지도 C++ 표준에서는 이를 완전히 해결할 수 있는 언어 차원의 구조적 해결책이 부족
“C++에도 Java의 default처럼 static initializer를 안전하게 제어할 수 있는 구조가 들어왔으면 좋겠다”는 바람은, 언어 설계의 진화가 얼마나 어려운지를 보여주는 사례다.


## 6. 결론: 언어는 철학이자 타협이다
Java의 default 메서드는 단순한 기능이 아니라,
언어 설계 철학이 현실과 충돌했을 때 어떤 선택을 했는지를 보여주는 상징적인 사건이다.
그리고 그 선택은 개발자에게 더 나은 확장성과 유지보수를 제공했지만, 동시에 순수 객체지향의 이상을 일부 포기한 결과이기도 하다.

## 📚 이 글이 담고자 하는 메시지
- 언어 설계는 이상과 현실 사이의 줄다리기다
- 하위 호환성은 안정성을 주지만, 진화를 막기도 한다
- Java의 default는 그 균형을 찾기 위한 첫 번째 균열이었다
- C++ 역시 static 초기화 문제처럼, 언어 설계의 한계를 마주하고 있다
---
