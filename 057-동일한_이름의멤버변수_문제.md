# 동일한 이름의 멤버 변수에 대한 처리


## 🔍 C++에서 부모 클래스의 private 멤버와 자식 클래스의 동일 이름 멤버
```cpp
class Base {
private:
    int value = 10;
};

class Derived : public Base {
private:
    int value = 20;
};
```

- 여기서 Derived 클래스는 Base 클래스의 value와 동일한 이름의 멤버를 선언했지만, Base::value는 private이므로 Derived에서는 접근 불가입니다.
- Derived의 value는 Base의 value를 숨기고(name hiding), 완전히 새로운 멤버로 취급됩니다.
- 즉, 두 변수는 메모리상 별개이며, Base::value는 Derived 내부에서 접근할 수 없고, Derived::value만 사용됩니다.


## 🧪 C# 샘플: 부모와 자식 클래스에 동일한 이름의 멤
```csharp
using System;

namespace MemberHidingDemo
{
    class Parent
    {
        private int value = 10;

        public void ShowParentValue()
        {
            Console.WriteLine("Parent value: " + value);
        }
    }

    class Child : Parent
    {
        private int value = 20; // 부모와 동일한 이름의 멤버

        public void ShowChildValue()
        {
            Console.WriteLine("Child value: " + value);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Child obj = new Child();
            obj.ShowParentValue(); // 출력: Parent value: 10
            obj.ShowChildValue();  // 출력: Child value: 20
        }
    }
}
```


## 🧭 언어별 상속 시 동일 이름 멤버 처리 비교

| 언어         | 부모의 `private` 멤버 접근 | 동일 이름 멤버 선언 시 처리 방식         | 특징 및 주의점 |
|--------------|-----------------------------|------------------------------------------|----------------|
| **C++**      | ❌ 불가능                    | 이름 숨김 (name hiding), 별개 멤버로 취급 | `Base::value`는 `Derived`에서 접근 불가. 메모리상 별도 존재. |
| **Java**     | ❌ 불가능                    | 부모 멤버 숨김, 자식에서 새로 정의됨      | `private` 멤버는 상속되지 않음. 자식에서 같은 이름 사용 가능. |
| **C#**       | ❌ 불가능                    | `new` 키워드로 명시적 숨김 가능           | `new` 없이 선언하면 경고 발생. 부모 멤버와 별개로 동작. |
| **Python**   | ⚠️ 가능 (name mangling)     | 이름 숨김 없음, 내부적으로 접근 가능      | `__var` → `_ClassName__var`로 변경되어 접근 가능. 숨김 효과는 제한적. |
| **JavaScript** | ⚠️ 제한적 (`#private`)     | 덮어쓰기됨, 상속 구조에서 캡슐화 어려움    | ES6 이후 `#` 사용 가능하지만 상속 구조에서는 제한적. 대부분 public 속성 덮어쓰기. |

## 📌 요약 포인트
- C++, Java, C#은 엄격한 캡슐화를 지향하며, 동일 이름 멤버는 별개로 취급됨.
- Python은 name mangling을 통해 접근은 가능하지만, 숨김 효과는 약함.
- JavaScript는 캡슐화가 약한 언어로, 상속 구조에서 private 멤버 관리가 까다로움.


## 🧠 추가 설명
- C++: Base::value는 Derived에서 접근 불가. Derived가 같은 이름으로 선언하면 Base의 멤버는 숨겨지고, Derived의 멤버만 보임.
- Java: private 멤버는 상속되지 않음. 자식 클래스에서 같은 이름을 쓰면 새 멤버로 간주.
- C#: new 키워드를 쓰면 부모 멤버를 명시적으로 숨길 수 있음. 안 쓰면 경고 발생.
- Python: __value는 내부적으로 _ClassName__value로 바뀌기 때문에, 자식 클래스에서도 접근은 가능하지만 일반적으로 숨김 효과 있음.
- JavaScript: #value 같은 private 필드는 ES6 이후에 도입되었지만, 상속 구조에서는 여전히 제한적. 대부분은 public 속성으로 덮어쓰기됨.

---


## 🧭 언어별 protected 멤버 이름 중복 처리 비교
| 언어         | 부모 `protected` 접근 가능 | 자식에서 동일 이름 선언 시 처리 방식 | 특징 및 동작 방식 |
|--------------|-----------------------------|--------------------------------------|-------------------|
| **C++**      | ✅ 가능                      | 이름 숨김 (name hiding) 발생          | 부모 멤버는 숨겨지며, 자식 멤버가 우선됨. `Base::member`로 명시적 접근 가능. |
| **Java**     | ✅ 가능                      | 자식 멤버가 부모 멤버를 숨김          | 부모 멤버는 여전히 존재하지만 자식에서 같은 이름 쓰면 부모 멤버 접근 어려움. |
| **C#**       | ✅ 가능                      | `new` 키워드로 명시적 숨김 가능       | `new` 없이 선언하면 경고 발생. 부모 멤버는 숨겨지고 자식 멤버가 우선됨. |
| **Python**   | ⚠️ 가능 (`_protected`)       | 이름 숨김 없음, 덮어쓰기됨            | 명시적 접근 가능 (`super().member`), 이름 중복 시 자식 멤버가 우선됨. |
| **JavaScript** | ❌ 없음 (`protected` 불지원) | 덮어쓰기됨                            | `protected` 개념 없음. 동일 이름 사용 시 자식 멤버가 부모 멤버를 덮어씀. |


## 🔍 핵심 차이 요약
- C++: protected 멤버는 자식에서 접근 가능하지만, 동일 이름 선언 시 부모 멤버는 숨겨짐. Base::member로 명시적 접근 가능.
- Java: 비슷하게 숨겨지지만, super.member로 접근 가능. 다만 자식 멤버가 우선됨.
- C#: new 키워드를 써서 명시적으로 숨김 처리 가능. 안 쓰면 경고 발생.
- Python: protected는 관례상 _member로 표현. 이름 중복 시 자식 멤버가 우선되며 super()로 부모 멤버 접근 가능.
- JavaScript: protected 자체가 없기 때문에, 동일 이름 사용 시 그냥 덮어쓰기됨.

## 🧪 C# 예제: protected 멤버 이름 중복
```csharp
class Parent
{
    protected int value = 10;
}

class Child : Parent
{
    protected new int value = 20;

    public void ShowValues()
    {
        Console.WriteLine("Child value: " + value);       // 20
        Console.WriteLine("Parent value: " + base.value); // 10
    }
}
```        

- new 키워드를 사용하면 명시적으로 부모 멤버를 숨김.
- base.value를 통해 부모 멤버에 접근 가능.


## 🧠 C#에서 부모로 캐스팅할 때의 동작
```csharp
class Parent
{
    protected int value = 10;
}

class Child : Parent
{
    protected new int value = 20;

    public void ShowValues()
    {
        Console.WriteLine("Child value: " + value);              // 20
        Console.WriteLine("Parent value: " + ((Parent)this).value); // 10
    }
}
```

## 🔍 설명
- Child 클래스에서 value를 new 키워드로 다시 선언하면, 부모의 value는 숨겨짐.
- 하지만 Parent 타입으로 캐스팅하면, 숨겨졌던 부모의 value가 다시 보이게 됩니다.
- 즉, 같은 이름의 멤버가 두 개 존재하고, 타입에 따라 어떤 멤버가 보이는지가 달라져요.

## 🧪 C++에서도 비슷한 현상
```cpp
class Parent {
protected:
    int value = 10;
};

class Child : public Parent {
protected:
    int value = 20;
};

int main() {
    Child c;
    Parent* p = &c;
    std::cout << "Parent value: " << p->value << std::endl; // 10
    std::cout << "Child value: " << c.value << std::endl;   // 20
}
```

- Parent*로 캐스팅하면 부모의 value가 보이고,
- Child 타입에서는 자식의 value가 보입니다.

## 🔍 상속 구조에서 동일 이름 멤버의 캐스팅 동작 요약

| 상황                          | 접근 대상 멤버 | 설명 |
|-------------------------------|----------------|------|
| 자식 클래스에서 직접 접근       | 자식 멤버       | 자식 클래스에 동일 이름의 멤버가 있으면 부모 멤버는 숨겨짐 (name hiding) |
| 부모 타입으로 캐스팅 후 접근    | 부모 멤버       | 부모 타입으로 캐스팅하면 숨겨졌던 부모 멤버가 다시 보임 |
| `base` 또는 `super` 키워드 사용 | 부모 멤버       | 명시적으로 부모 멤버를 참조할 수 있음 (C#, Java, Python 등) |

---
