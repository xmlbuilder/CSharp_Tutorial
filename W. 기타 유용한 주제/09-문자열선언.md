# 🧠 문자열 선언

코드 분석 및 의도 추정
```csharp
string s = "hello";
char[] chars = new char[] { 'h', 'e', 'l', 'l', 'o' };
string s1 = new string(chars, 0, chars.Length);
```

##  s: 일반적인 문자열 선언
-  char를 통한 문자열 선언 가능


## unsafe를 통한 문자열
```csharp
unsafe
{
    fixed (char* charPointer = "hello")
    {
        s2 = new string(charPointer);
    }
}
Console.WriteLine(s2);
```

- unsafe 블록에서 문자열 "hello"의 포인터를 고정
- new string(charPointer)로 포인터 기반 문자열 생성
- 결과는 "hello"
## 🔍 문자열을 포인터로 직접 접근해서 new string(char*) 생성이 가능한지 실험.
이건 C#에서 native interop이나 low-level memory control을 할 때 필요한 방식이에요. 
특히 C/C++과 연동하거나, 성능 최적화 실험할 때 자주 쓰는 패턴입니다.


## 🧩 전체 흐름 요약
| 변수명 | 생성 방식                         | 결과값     | 설명 및 의도 추정 |
|--------|----------------------------------|------------|-------------------|
| `s`    | 문자열 리터럴 직접 할당          | `"hello"`  | 가장 기본적인 문자열 선언 방식 |
| `chars`| 문자 배열 생성                   | `{'h','e','l','l','o'}` | char를 통한 문자열  |
| `s1`   | `new string(chars, 0, chars.Length)` | `"hell0"`  | 문자 배열을 기반으로 문자열 생성. `'0'`이 포함된 결과 확인 목적 |
| `s2`   | `unsafe` 블록에서 포인터 기반 생성 | `"hello"`  | 문자열을 포인터로 직접 접근해 생성. low-level 메모리 제어 실험 |




## 💬 정리된 설명 (문서용)
이 코드는 C#에서 문자열을 다양한 방식으로 생성하는 실험을 담고 있다.
- s1은 char[] 배열을 기반으로 문자열을 생성하며, 배열 내 문자에 따라 결과가 달라진다.
- s2는 unsafe 블록을 통해 문자열 리터럴의 포인터를 고정하고, 이를 기반으로 문자열을 생성하는 방식이다.
이는 C#에서 메모리 직접 접근이 필요한 상황이나, native 코드와 연동할 때 유용한 패턴이다.

---


