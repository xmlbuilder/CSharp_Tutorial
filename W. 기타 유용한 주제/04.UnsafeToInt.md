# ğŸ” ì½”ë“œ í•µì‹¬ ìš”ì•½
ì´ ì½”ë“œëŠ” ë‹¤ìŒ ë‘ ê°€ì§€ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤:
## 1. Unsafe.As<byte, int>ë¡œ reinterpret cast
ref int r = ref Unsafe.As<byte, int>(ref b[0]);


- byte[] ë°°ì—´ì˜ ì²« ë²ˆì§¸ ë°”ì´íŠ¸ë¥¼ intë¡œ reinterpret
- 0x42ê°€ 4ê°œ â†’ 0x42424242ë¡œ í•´ì„ë¨
- ë©”ëª¨ë¦¬ ë³µì‚¬ ì—†ì´ ì§ì ‘ ì°¸ì¡°
## 2. ìˆ˜ë™ ë°”ì´íŠ¸ ì‹œí”„íŠ¸ë¡œ int êµ¬ì„±
int bVal = (int)(b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]);


- ë°”ì´íŠ¸ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì‹œí”„íŠ¸í•´ì„œ intë¡œ ì¡°ë¦½
- ê²°ê³¼ì ìœ¼ë¡œ bVal == r == 0x42424242

## âš ï¸ ì‹¤ë¬´ì—ì„œì˜ ì£¼ì˜ì 
- UnsafeëŠ” ì •ë§ ê°•ë ¥í•˜ì§€ë§Œ ëŸ°íƒ€ì„ ì•ˆì •ì„±ì„ í•´ì¹  ìˆ˜ ìˆì–´ìš”.
- í”Œë«í¼ì— ë”°ë¼ ì—”ë””ì•ˆ(Endian) ë¬¸ì œê°€ ìƒê¸¸ ìˆ˜ ìˆìŒ
- byte[] í¬ê¸°ê°€ sizeof(int)ë³´ë‹¤ ì‘ìœ¼ë©´ ì˜ˆì™¸ ì—†ì´ ì˜ëª»ëœ ê°’ì„ ì½ì„ ìˆ˜ ìˆìŒ

## ğŸ’¡ ì‹¤ë¬´ìì—ê²Œ ìœ ìš©í•œ í¬ì¸íŠ¸
ì´ëŸ° ì½”ë“œëŠ” ë‹¤ìŒ ìƒí™©ì—ì„œ ìœ ìš©í•  ìˆ˜ ìˆì–´ìš”:
- ì„±ëŠ¥ ìµœì í™”ê°€ ì¤‘ìš”í•œ ê²Œì„ ì—”ì§„, ì‹œë®¬ë ˆì´ì…˜, ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ì²˜ë¦¬
- ë©”ëª¨ë¦¬ ë§µ íŒŒì¼ì´ë‚˜ ë°”ì´ë„ˆë¦¬ í¬ë§· íŒŒì‹±
- Span<T>, MemoryMarshal ë“±ê³¼ í•¨ê»˜ ì“°ë©´ ë” ì•ˆì „í•˜ê²Œ í™œìš© ê°€ëŠ¥

## ì½”ë“œ

```csharp
using System;
using System.Runtime.InteropServices;

namespace GrammarTest
{
    class Program
    {
        public static void Main(string[] args)
        {
            byte[] b = new byte[4] { 0x42, 0x42, 0x42, 0x42 };

            // Span<byte>ë¡œ ë˜í•‘
            Span<byte> span = b;

            // reinterpret cast: byte[] â†’ int
            int value = MemoryMarshal.Read<int>(span);

            Console.WriteLine(value == 0x42424242); // True

            // ìˆ˜ë™ ë°”ì´íŠ¸ ì‹œí”„íŠ¸
            int bVal = (int)(b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]);

            Console.WriteLine(bVal == 0x42424242); // True
        }
    }
}
```


## ğŸ”„ ì—”ë””ì•ˆ ì „í™˜ì— ìœ ìš©í•œ Span<byte> í™œìš© ì˜ˆì‹œ
ì˜ˆë¥¼ ë“¤ì–´, Big-Endian ë°”ì´íŠ¸ ë°°ì—´ì„ intë¡œ ë³€í™˜í•˜ë ¤ë©´:
```csharp
Span<byte> bigEndianBytes = stackalloc byte[4] { 0x42, 0x42, 0x42, 0x42 };

// Big-Endian â†’ Little-Endian ë³€í™˜
int value = (bigEndianBytes[0] << 24) |
            (bigEndianBytes[1] << 16) |
            (bigEndianBytes[2] << 8)  |
            (bigEndianBytes[3]);

Console.WriteLine(value == 0x42424242); // True
```

ì´ ë°©ì‹ì€:
- ë°”ì´íŠ¸ ìˆœì„œë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì œì–´í•  ìˆ˜ ìˆê³ 
- BitConverterë³´ë‹¤ ë¶ˆí•„ìš”í•œ ë³µì‚¬ ì—†ì´ ë¹ ë¦„
- Span<byte>ëŠ” ìŠ¤íƒ ê¸°ë°˜ì´ë¼ GC ë¶€ë‹´ë„ ì—†ìŒ

ğŸ’¡ ë°˜ëŒ€ë¡œ Little-Endian â†’ Big-Endian ë³€í™˜ë„ ê°€ëŠ¥
```csharp
Span<byte> littleEndianBytes = stackalloc byte[4];
int value = 0x42424242;

littleEndianBytes[0] = (byte)(value >> 0);
littleEndianBytes[1] = (byte)(value >> 8);
littleEndianBytes[2] = (byte)(value >> 16);
littleEndianBytes[3] = (byte)(value >> 24);
```

ì´ë ‡ê²Œ í•˜ë©´ Little-Endian í˜•ì‹ìœ¼ë¡œ intë¥¼ ë°”ì´íŠ¸ ë°°ì—´ë¡œ ë³€í™˜í•  ìˆ˜ ìˆì–´ìš”.

## âœ¨ ì‹¤ë¬´ íŒ
- ë„¤íŠ¸ì›Œí¬ í”„ë¡œí† ì½œ, ë°”ì´ë„ˆë¦¬ íŒŒì¼ í¬ë§·, GPU ë²„í¼ ë“±ì—ì„œëŠ” Big-Endianì´ í‘œì¤€ì¸ ê²½ìš°ê°€ ë§ì•„ìš”.
- Span<byte>ë¥¼ ì“°ë©´ í”Œë«í¼ ë…ë¦½ì ì¸ ì—”ë””ì•ˆ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•´ì„œ ì´ì‹ì„±ë„ ì¢‹ì•„ìš”.
- í•„ìš”í•˜ë©´ BinaryPrimitives.ReverseEndianness() ê°™ì€ .NET ë©”ì„œë“œë„ í™œìš© ê°€ëŠ¥!
