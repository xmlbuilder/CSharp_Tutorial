📚 공변성(Covariance) & 반공변성(Contravariance) 요약
## 🔁 가변성(Variance) 개요

| 개념       | 설명                                                                 |
|------------|----------------------------------------------------------------------|
| 공변성     | `X → Y`일 때, `C<X> → C<Y>`도 가능하면 공변성 (출력 위치에서 안전)     |
| 반공변성   | `X → Y`일 때, `C<Y> → C<X>`도 가능하면 반공변성 (입력 위치에서 안전)     |
| 불변성     | `X → Y`여도 `C<X>`는 `C<X>`로만 사용 가능 (기본 제네릭은 불변)          |

## ✅ C#에서의 키워드

| 키워드 | 의미        | 사용 위치 예시                          |
|--------|-------------|------------------------------------------|
| `out`  | 공변성 지정 | 반환 타입, `get` 접근자, `Func<T>` 등     |
| `in`   | 반공변성 지정 | 입력 타입, `set` 접근자, `Action<T>` 등   |

## 🧠 예시로 이해하기

| 예시 코드                          | 설명                                      |
|-----------------------------------|-------------------------------------------|
| `IEnumerable<Base> = IEnumerable<Derived>` | `out T`로 공변성 허용됨 (출력만 사용)        |
| `IComparable<Derived> = IComparable<Base>` | `in T`로 반공변성 허용됨 (입력만 사용)        |
| `Base[] items = new DerivedA[5]`  | 배열은 공변적이지만 입력 시 예외 발생 가능     |

## ⚠️ 왜 위치가 중요할까?

| 위치      | 공변성 위험성 예시                             |
|-----------|------------------------------------------------|
| 입력 위치 | `items[0] = new DerivedB()` → 런타임 예외 발생   |
| 출력 위치 | 안전하게 `Base`로 읽을 수 있음                  |

## 🧩 C++과의 연결: lvalue vs rvalue

| C++ 개념     | 연결되는 의미                                     |
|--------------|--------------------------------------------------|
| `lvalue`     | 메모리에 존재하는 값 → 입력 위치와 유사             |
| `rvalue`     | 임시 값 → 출력 위치와 유사                         |
| `T&&`        | rvalue reference → 출력 전용으로 안전하게 사용 가능 |



## 🔍 핵심 통찰
- 공변성은 출력 위치에서만 안전: 값을 꺼내는 용도로만 쓰일 때 타입 확장이 허용됨.
- 반공변성은 입력 위치에서만 안전: 값을 넣는 용도로만 쓰일 때 타입 축소가 허용됨.
- C++의 rvalue/lvalue는 메모리와 수명 관점에서 공변성과 철학적으로 연결됨: rvalue는 "읽기 전용", lvalue는 "쓰기 가능"이라는 점에서.


## 🧭 공변성: 출력만 할 때 안전하다
Base[] items = new DerivedA[5]; // 배열은 공변적
Base item = items[0];           // DerivedA를 Base로 읽는 건 안전


- 여기서 items는 DerivedA[]인데, Base[]로 할당했죠.
- items[0]을 읽을 때는 Base로 읽으니까 문제 없어요. 출력 위치니까 안전한 공변성입니다.
하지만…
items[0] = new DerivedB(); // ❌ 런타임 예외 발생


- items는 실제로 DerivedA[]인데, DerivedB를 넣으려 하니 타입이 안 맞아요.
- 입력 위치에서 공변성을 쓰면 위험해요. 그래서 C#에서는 out T로 공변성을 제한합니다.

## 🧭 반공변성: 입력만 할 때 안전하다
IComparable<DerivedA> test = new Base(); // Base는 IComparable<Base> 구현
test.CompareTo(new DerivedA());          // 입력 위치에서 DerivedA를 받음


- IComparable<in T>는 반공변적으로 정의되어 있어요.
- test는 DerivedA를 비교해야 하는데, 실제 구현은 Base.CompareTo입니다.
- Base.CompareTo(Base other)는 DerivedA도 받을 수 있으니 안전하죠.
즉, 입력 위치에서 타입이 더 일반적인 쪽으로 바뀌는 건 괜찮아요. 그래서 in T로 반공변성을 지정합니다.

## 전체 코드
```csharp

namespace GrammarTest
{
    class Base: IComparable<Base> 
    { 
        public int Id { get; set; } 
        public string Content { get; set; }
        public int CompareTo(Base? other)
        {
            throw new NotImplementedException();
        }
    } 
    class DerivedA: Base{ } 
    class DerivedB: Base{ }
}

class Program
{
    static int Main(string[] args)
    {
        Base[] items = new DerivedA[5]
        {
            new DerivedA(),
            new DerivedA(),
            new DerivedA(),
            new DerivedA(),
            new DerivedA(),
        }; 
        var item = items[0]; // 문제가 없습니다. 이를 공변적이라고합니다.
        
        item.DoSomething();
        return 0;
    }
}

// 하지만 출력위치가 아닌 입력위치에서 쓰이면 안전하지 않게 된다.
// item[0] = new DerivedB { Id = 2, Content = "B"}; // Throw Exception, 공변적일 때 입력위치는 위험합니다.

// 트위터의 스칼라 공식문서에서는 오리는 닭짓을 할 수 없기 때문에 메서드 파라미터(입력위치)는 항상 반공변적이다. 
// 일반적으로 공변성에서의 입력위치는 위험요소가 항상 있기 때문에 공변성은 항상 출력위치에서 쓰이도록 만들어진 것이다.


IComparable<DerivedA> test = new Base(); 
test.CompareTo(new DerivedA()); 


// test.CompareTo는 실제로 Base.CompareTo로 동작하며 
// Base.CompareTo의 입력위치인 파라미터는 DerviedA를 받을 수 있다.
// IComparable<in T>일 때 IComparable<DerivedA>가 IComparable<Base>를 받을 수 있는 이유이다.
// 공변성과 마찮가지로 왜 반공변성은 입력위치에서만 사용하도록 되어있을까? 반공변성이 만약 출력위치에서 사용할 수 있다고 가정해보자.

CustomList<DerivedA> items = new CustomList<object>(); 
items.Put(1); 
items.Put("string"); 
items.Put(5.1F); 
items.Put(new DerivedB()); 
var value= items.Get(1); // What kinds of type?

// 반공변성의 경우 입력할때는 아무 값이나 넣을 수 있지만 
// 반환되는 값에 대해선 어떤 타입인지 전혀 추론이 불가능하기 때문에 에러를 유발할 수 있기 때문이다.


//델리게이트에서의 공변과 반공변

public interface ICovariantDelegates<out T> 
{ 
    T GetAnItem(); 
    Func<T> GetAnItemLater(); 
    void GiveAnItemLater(Action<T> whatToDo); 
}

// 위 예제에서 GetAnItem은 T가 출력위치에 있음으로 전혀 문제될 것이 없다. 또한 GetAnItemLater의 Func<T>또한 출력 위치에 있으므로 명확하다. 
// 하지만 GiveAnItemLater은 T가 입력 위치에 있어 반공변이 되어야할 것 같지만 실제로 whatToDo가 T를 취하는 형태이므로 공변하다.


public interface IContravariantDelegates<in T> 
{
    void ActOnAnItem(T item); 
    void GetAnItemLater(Func<T> item); 
    Action<T> ActOnAnItemLater(); 
}

```

## 🧠 델리게이트에서의 위치 판단
```csharp
public interface ICovariantDelegates<out T>
{
    T GetAnItem();                  // 출력 위치 → 공변성
    Func<T> GetAnItemLater();       // 출력 위치 → 공변성
    void GiveAnItemLater(Action<T> whatToDo); // 입력 위치 → 반공변성
}
```

- Func<T>는 값을 반환하니까 출력 위치 → 공변성
- Action<T>는 값을 받아들여 처리하니까 입력 위치 → 반공변성

## 📊 요약 표: 위치에 따른 안전성
| 위치       | 예시 코드                          | 안전한 가변성 | 설명                                  |
|------------|------------------------------------|----------------|---------------------------------------|
| 출력 위치  | `Base item = items[0];`            | 공변성         | 읽기만 하므로 타입 확장이 안전함         |
| 입력 위치  | `items[0] = new DerivedB();`       | ❌ 위험         | 실제 배열 타입과 달라서 예외 발생         |
| 입력 위치  | `test.CompareTo(new DerivedA());` | 반공변성       | 일반 타입(Base)으로 받아들이는 건 안전함  |
| 출력 위치  | `Func<T>`                          | 공변성         | 반환 타입이므로 타입 확장이 안전함        |
| 입력 위치  | `Action<T>`                        | 반공변성       | 입력 타입이므로 타입 축소가 안전함        |


이제 공변성과 반공변성이 왜 위치에 따라 다르게 동작해야 하는지, 그리고 C#에서 어떻게 안전하게 제어하는지 훨씬 더 명확하게 보이죠.



## 🧪 C#에서 함수 인자 vs 반환값으로 본 공변성과 반공변성
### 1️⃣ 함수 인자: 입력 위치 → 반공변성
```cpp
public interface IProcessor<in T>
{
    void Process(T item); // T는 입력 위치 → 반공변성
}
```

- in T는 반공변성을 의미해요.
- IProcessor<Base>는 IProcessor<Derived>에 할당 가능해요.
- 왜냐하면 Base는 Derived를 받아들일 수 있으니까요.
### 📌 예시
```cpp
IProcessor<DerivedA> processor = new BaseProcessor(); // BaseProcessor : IProcessor<Base>
processor.Process(new DerivedA()); // 안전하게 처리됨
```


### 2️⃣ 함수 반환값: 출력 위치 → 공변성
```cpp
public interface IFactory<out T>
{
    T Create(); // T는 출력 위치 → 공변성
}
```

- out T는 공변성을 의미해요.
- IFactory<Derived>는 IFactory<Base>에 할당 가능해요.
- 왜냐하면 Derived는 Base로 안전하게 반환될 수 있으니까요.
### 📌 예시
```cpp
IFactory<Base> factory = new DerivedFactory(); // DerivedFactory : IFactory<Derived>
Base item = factory.Create(); // 안전하게 Base로 받을 수 있음
```



## 📌 위치에 따른 가변성 요약

| 위치       | 키워드 | 예시 인터페이스       | 적용되는 가변성 | 안전한 방향성                   | 설명 |
|------------|--------|------------------------|------------------|-------------------------------|------|
| 입력 위치  | `in`   | `IProcessor<in T>`     | 반공변성         | 일반 → 구체 (Base → Derived)   | 입력값을 받아 처리할 때 안전 |
| 출력 위치  | `out`  | `IFactory<out T>`      | 공변성           | 구체 → 일반 (Derived → Base)   | 반환값을 전달할 때 안전       |



## 🧭 이제 C++로 넘어가보자!
C++에는 in, out 키워드가 없지만, 템플릿과 참조 타입, 특히 lvalue와 rvalue를 통해 유사한 개념을 표현할 수 있어요.
### 🔹 C++에서 입력 위치: T& 또는 const T&
```cpp
void process(const Base& item); // 입력 위치 → Derived도 받을 수 있음
```

- Derived는 Base로 업캐스팅 가능하므로 안전
- 이건 C#의 반공변성과 유사
### 🔹 C++에서 출력 위치: Base* 또는 unique_ptr<Base>
```cpp
std::unique_ptr<Base> create() {
    return std::make_unique<Derived>();
}
```

- Derived를 Base로 반환 → 안전
- 이건 C#의 공변성과 유사

## 🧭 C++에서의 위치 기반 가변성 요약

| 위치       | C++ 표현 방식                     | 대응되는 가변성 | 안전한 방향성                   | 설명 |
|------------|-----------------------------------|------------------|-------------------------------|------|
| 입력 위치  | `const T&`, `T&&`, `T*`           | 반공변성 유사    | 일반 → 구체 (Base → Derived)   | 파라미터로 받을 때, 업캐스팅 가능 |
| 출력 위치  | `T`, `T*`, `unique_ptr<T>`        | 공변성 유사      | 구체 → 일반 (Derived → Base)   | 반환값으로 전달할 때, 다운캐스팅 가능 |
| 템플릿 위치| `template<typename T>`            | 불변성 기본      | T는 고정                        | 명시적 타입 지정 없으면 타입 추론 제한 |
| 함수 객체  | `std::function<Base()>`           | 공변성 유사      | Derived → Base 반환 가능        | 반환 타입이 Base면 Derived도 허용됨 |
| 람다 인자  | `std::function<void(Base)>`       | 반공변성 유사    | Base → Derived 인자 허용        | Base 타입 인자로 Derived 전달 가능 |


### 🧠 1. Template과 가변성
C++의 template<typename T>는 기본적으로 불변성이에요. 타입이 명시되면 그 타입으로만 동작하죠.
```cpp
template<typename T>
class Container {
public:
    void put(const T& value); // 입력 위치
    T get();                  // 출력 위치
};
```

- put()은 입력 위치 → 반공변성처럼 동작 가능
- get()은 출력 위치 → 공변성처럼 동작 가능
하지만 C++은 in, out 키워드가 없기 때문에 타입 안전성은 개발자가 직접 책임져야 해요.

### 🧠 2. std::function과 위치 기반 타입 흐름
```cpp
std::function은 함수 객체를 표현하는 템플릿으로, 입력과 출력 타입을 명시할 수 있어요.
std::function<Base()> factory;           // 출력 위치 → 공변성 유사
std::function<void(Base)> processor;     // 입력 위치 → 반공변성 유사
```

### 📌 예시:
```cpp
std::function<Base()> f = []() -> DerivedA {
    return DerivedA(); // DerivedA → Base 반환 가능 (공변적)
};

std::function<void(Base)> g = [](DerivedA d) {
    // DerivedA → Base로 전달 가능 (반공변적)
};
```

- 반환 타입은 Derived → Base로 업캐스팅 가능 → 공변성
- 인자 타입은 Base → Derived로 다운캐스팅 가능 → 반공변성

### 🧠 3. rvalue/lvalue와 위치 개념
C++의 참조 타입은 값의 수명과 사용 위치를 구분하는 데 핵심이에요.

## 🧭 C++ 참조 타입과 위치 개념 요약

| 참조 타입     | 위치 개념     | 값의 수명 관점           | 사용 목적 및 특징                                      |
|---------------|---------------|---------------------------|--------------------------------------------------------|
| `T&`          | 입력 위치     | lvalue (명명된 객체)      | 수정 가능한 참조. 함수 인자로 전달할 때 사용됨.         |
| `const T&`    | 입력 위치     | lvalue (불변 참조)        | 읽기 전용 참조. 복사 비용 줄이면서 안전하게 전달 가능.  |
| `T&&`         | 출력 위치     | rvalue (임시 객체)        | 이동 시멘틱을 위한 참조. 자원 소유권 이전에 사용됨.     |
| `auto&&`      | 위치 추론     | lvalue/rvalue 모두        | universal reference. perfect forwarding에 사용됨.       |


## 📌 예시:
```cpp
void process(const Base& item); // 입력 위치 → 반공변성 유사
Base create();                  // 출력 위치 → 공변성 유사
```

- const Base&는 Derived도 받을 수 있음 → 안전한 입력
- create()에서 Derived를 반환해도 Base로 받을 수 있음 → 안전한 출력

## 🔁 C++에서의 위치 기반 가변성 요약

| 위치       | 표현 방식                          | 대응되는 가변성 | 안전한 방향성                   | 설명 |
|------------|-------------------------------------|------------------|-------------------------------|------|
| 입력 위치  | `const T&`, `T&&`, `T*`             | 반공변성 유사    | 일반 → 구체 (Base → Derived)   | 파라미터로 받을 때 안전 |
| 출력 위치  | `T`, `T*`, `unique_ptr<T>`          | 공변성 유사      | 구체 → 일반 (Derived → Base)   | 반환값으로 전달할 때 안전 |
| 함수 객체  | `std::function<Base()>`             | 공변성 유사      | Derived → Base 반환 가능        | 출력 위치 |
| 함수 객체  | `std::function<void(Base)>`         | 반공변성 유사    | Base → Derived 인자 허용        | 입력 위치 |
| 템플릿     | `template<typename T>`              | 불변성 기본      | T는 고정                        | 명시적 타입 지정 필요 |


--------------------------------------

## 🚀 Perfect Forwarding이란?
**완벽 전달(perfect forwarding)**은 함수 템플릿이 인자의 **원래 성격(lvalue인지 rvalue인지)**을 유지한 채 다른 함수로 전달할 수 있도록 하는 기술입니다.
###  🔧 핵심 구성
```cpp
template<typename T>
void wrapper(T&& arg) {
    callee(std::forward<T>(arg)); // perfect forwarding
}
```

- T&&는 universal reference (또는 forwarding reference)
- std::forward<T>(arg)는 arg가 lvalue면 lvalue로, rvalue면 rvalue로 전달

### 🧪 왜 필요한가?
예시: 복사 vs 이동
```cpp
void callee(std::string&& s); // rvalue만 받음

template<typename T>
void wrapper(T&& arg) {
    callee(std::forward<T>(arg)); // 이동 or 복사 결정됨
}
```

- wrapper("hello") → "hello"는 rvalue → 이동됨
- std::string str = "hi"; wrapper(str) → str은 lvalue → 복사됨
📌 즉, 인자의 성격을 유지하면서 최적의 방식으로 전달할 수 있음


## 🔍 Perfect Forwarding 내부 동작 요약

| 호출 방식                  | `T` 추론 결과     | `T&&` 타입           | `std::forward<T>(arg)` 결과 | 설명 |
|----------------------------|-------------------|----------------------|-----------------------------|------|
| `wrapper(obj)` (lvalue)    | `T = Type&`       | `Type& && → Type&`   | lvalue로 전달됨             | 원래 lvalue였으므로 복사 또는 참조 |
| `wrapper(Type())` (rvalue) | `T = Type`        | `Type&&`             | rvalue로 전달됨             | 이동 시멘틱 적용 가능             |



## 🧩 실전에서의 활용
- STL의 emplace_back(), make_unique(), make_shared() 등은 모두 perfect forwarding을 활용
- 라이브러리 설계 시, API 유연성과 성능을 동시에 확보할 수 있음

## 📘 마무리 요약
#### 🔁 Perfect Forwarding 요약

| 요소                  | 설명                                                   |
|-----------------------|--------------------------------------------------------|
| `T&&`                 | universal reference (입력 위치 + 위치 추론)             |
| `std::forward<T>(arg)`| 인자의 lvalue/rvalue 성격을 유지하며 전달               |
| 목적                  | 복사/이동 여부를 자동 결정 → 성능 최적화 + 타입 안전성 |
| 활용 예시             | `emplace_back`, `make_unique`, 커스텀 래퍼 함수 등      |

----

