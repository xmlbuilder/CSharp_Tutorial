# C# `delegate` 클로저 vs C++ 람다 클로저 비교

## 개념 요약

-   **클로저(Closure)**: 함수가 **자신이 선언된 환경의 변수(자유
    변수)**를 캡처하여, 이후 호출 시에도 그 변수에 접근할 수 있게 하는
    메커니즘.
-   **C#**: 람다/익명메서드는 **변수(로컬)**를 **참조(reference)**로
    캡처(호이스팅)하는 것이 기본. 같은 변수를 공유하는 모든 람다가
    **하나의 캡처 객체(클래스 필드)**를 본다.
-   **C++**: 람다는 캡처 목록에서 **값 캡처**(`[foo]`)와 **참조
    캡처**(`&foo`)를 선택한다. 캡처 방식에 따라 동작이 달라진다.

------------------------------------------------------------------------

## 1) 질문의 C# 예제와 동작 원리

``` csharp
using System;

class Program
{
    delegate int testDel();

    public static void Main(string[] args)
    {
        int foo = 4;
        testDel myClosure = () =>
        {
            return foo;
        };

        foo = 5;
        int bar = myClosure(); // <-- 이 시점의 foo = 5

        foo = 6;
        Console.WriteLine(bar); // 5  (4도 6도 아님)
    }
}
```

### 왜 5가 출력되나?

-   C#은 로컬 변수 `foo`를 **참조로 캡처**한다. (컴파일러가 캡처 전용
    클래스를 만들어 필드로 보관)
-   `myClosure()`가 호출될 때 **당시의 `foo` 값(=5)** 를 읽어 반환한다.
-   이후 `foo = 6`으로 바꿔도 이미 `bar`에는 **호출 시점**의 반환값 5가
    들어갔으므로 출력은 5.

> 포인트: **캡처는 참조**, 값은 **호출 시점**에 읽힌다.

------------------------------------------------------------------------

## 2) C++에서 동일/유사 동작 만들기

### (A) C#과 동일한 "참조 캡처" 동작

``` cpp
#include <iostream>
#include <functional>

int main() {
    int foo = 4;

    // foo를 "참조"로 캡처 => [&foo]
    std::function<int()> myClosure = [&foo]() {
        return foo;
    };

    foo = 5;
    int bar = myClosure(); // 호출 시점의 foo(=5)를 읽음

    foo = 6;
    std::cout << bar << std::endl; // 5
}
```

-   `&foo`는 **참조 캡처**: 클로저가 **원본 변수**를 바라본다 → **호출
    시점 값**을 읽는다.
-   C# 예제와 같은 결과(5).

### (B) "값 캡처"로 스냅샷 고정하기

``` cpp
#include <iostream>
#include <functional>

int main() {
    int foo = 4;

    // foo를 "값"으로 캡처 => [foo]
    std::function<int()> snap = [foo]() {
        return foo;
    };

    foo = 5;
    std::cout << snap() << std::endl; // 4  (캡처 시점 값 고정)
}
```

-   `[foo]`는 **값 캡처**: **캡처 시점**의 `foo`가 클로저 내부에
    **복사**된다.
-   이후 원본 `foo` 변경과 무관.

### (C) 수명 이슈와 안전한 공유 상태

참조 캡처(`&foo`)는 **변수 수명**이 끝난 뒤 람다가 살아 있으면 **댕글링
참조** 위험.\
지속 공유 상태가 필요하면 **스마트 포인터**로 감싸 값 캡처를 권장:

``` cpp
#include <iostream>
#include <functional>
#include <memory>

int main() {
    auto foo = std::make_shared<int>(4);

    // 값 캡처이지만, 포인터 자체를 복사 → 안전하게 공유됨
    std::function<int()> read = [foo]() { return *foo; };
    std::function<void(int)> write = [foo](int v) { *foo = v; };

    write(5);
    int bar = read(); // 5

    write(6);
    std::cout << bar << std::endl; // 5 (호출 시점 반환값은 이미 bar에 저장됨)
}
```

-   람다들은 **같은 `shared_ptr<int>`** 를 복사로 보유 → 상태를 안전히
    공유.
-   스코프 밖으로 클로저가 나가도 **수명 관리**가 자동.

------------------------------------------------------------------------

## 3) 한눈에 비교 표

  ----------------------------------------------------------------------------
  항목                    C# 람다/델리게이트           C++ 람다
  ----------------------- ---------------------------- -----------------------
  기본 캡처 의미          로컬 변수 **참조 캡처**      캡처 목록으로 **값/참조
                          (호이스팅된 필드)            선택**

  호출 시점 값 vs 캡처    기본적으로 **호출 시점 값**  `[foo]` 값(캡처 시점),
  시점 값                 (참조 캡처)                  `&foo` 참조(호출 시점)

  멀티 클로저 공유        동일 변수 공유(동일 캡처     참조 캡처 또는
                          객체)                        `shared_ptr`로 공유

  수명 관리               캡처 객체는 GC 대상          참조 캡처는 수명 주의,
                                                       안전 공유는
                                                       `shared_ptr` 권장

  타입                    `delegate`/`Func`/`Action`   람다 +
                                                       `std::function`(필요
                                                       시)
  ----------------------------------------------------------------------------

------------------------------------------------------------------------

## 4) 실전 팁

-   C#과 동일한 동작을 C++에서 원하면 **`&foo` 참조 캡처**를 사용.
-   **스코프 밖으로 람다를 넘길 때**(비동기/콜백 저장 등) C++은 `&` 캡처
    위험 → `std::shared_ptr<T>`를 **값 캡처**로 공유하는 패턴이 안전.
-   성능 민감 구간에선 `std::function` 대신 **템플릿/auto 람다** 사용이
    더 빠를 수 있음(타입 소거 비용 제거).

------------------------------------------------------------------------

## 5) 요약

-   C# 예제의 출력이 5인 이유: **참조 캡처(호출 시점 읽기)** 때문이다.
-   C++에서도 `&foo`로 **같은 동작**을 만들 수 있다.\
    반대로 **스냅샷 고정**이 필요하면 `[foo]` 값 캡처를 사용하자.
-   **수명**과 **공유 상태**를 고려해야 할 때는 `std::shared_ptr` 기반의
    값 캡처가 실무적으로 가장 안전하다.
