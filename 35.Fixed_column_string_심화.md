# 🔍 코드 분석
```cpp
string s = "hello"; // 일반적인 문자열 선언

char[] chars = new char[] {'h', 'e', 'l', 'l', '0'};
string s1 = new string(chars, 0, chars.Length); // char 배열로부터 문자열 생성

string s2;
unsafe
{
    fixed (char* charPointer = "hello") // 문자열을 고정시켜 포인터로 접근
    {
        s2 = new string(charPointer); // 포인터로부터 문자열 생성
    }
}
Console.WriteLine(s2);
```


## 🧠 왜 이렇게 쓰는가?
### 1. new string(char[], int startIndex, int length)
#### - 용도: char[] 배열의 일부를 문자열로 변환할 때 사용
#### - 장점: 배열에서 원하는 부분만 추출 가능
#### - 단점: 배열이 있어야 하고, 복사 비용 발생
### 2. unsafe + fixed + char*
#### - 용도: 문자열을 포인터로 직접 접근해서 new string(char*) 생성
#### - 장점:
- 성능 최적화: 복사 없이 포인터로 직접 접근
- Interop: C/C++과의 연동 시 유용 (예: native API에서 char* 반환)
- 메모리 제어: 고정된 위치에서 작업 가능
#### - 단점:
- unsafe 코드 필요 → 보안 위험 및 런타임 검증 불가
- GC에 의해 이동될 수 있는 메모리를 다루므로 fixed로 고정 필요
- 일반적인 C# 개발에서는 권장되지 않음

## 📌 정리: 장단점 비교


| 방식                          | 장점                           |                                    | 사용                           |
|---------------------|----------------------------------|---------------------------------------|------------------------------------|
| `new string(char[], i, len)` | - 부분 추출 가능<br>- 안전한 코드          | - 배열 복사 필요<br>- 성능 낮음                        | 일반적인 문자열 생성   | `new string(char*)` + `unsafe` | - 고성능<br>- 포인터 직접 접근<br>- Interop에 유리 | - `unsafe` 필요<br>- 보안 위험<br>- 유지보수 어려움 | Native 연동, 성능 민감한 코드|



## ⚠️ 실무 팁
- unsafe 코드는 Interop이나 성능이 극도로 중요한 경우에만 사용하세요.
- 문자열을 다룰 때는 대부분 string, StringBuilder, Span<char>로 충분합니다.
- .NET Core 이후에는 Span<T>와 Memory<T>를 활용하면 안전하면서도 고성능을 얻을 수 있어요.


## 📌 C# 문자열 생성 및 조작 방식 비교

| 방식                   | 장점          | 단점                        | 사용 용도                      |
|--------------|--------------------------------------|---------------|----------------------------------|
| `new string(char[], i, len)` | - 배열 일부를 문자열로 변환 가능<br>- 안전한 코드  | - 배열 복사 필요<br>- 성능 낮음    | 일반적인 문자열 생성     |
| `new string(char*)` + `unsafe` | - 고성능<br>- 포인터 직접 접근<br>- Interop에 유리   | - `unsafe` 필요<br>- 보안 위험<br>- 유지보수 어려움   | Native 연동, 성능 민감한 코드   |
| `Span<char>`  | - 고성능<br>- 메모리 복사 없이 부분 접근 가능<br>- 안전한 구조체 기반 | - 문자열로 직접 변환하려면 `ToString()` 필요<br>- `ref struct` 제약 | 고성능 파싱, 버퍼 조작, 실시간 처리        |
| `StringBuilder`   | - 반복적인 문자열 조작에 최적화<br>- 메모리 할당 최소화   | - 초기 성능은 느릴 수 있음<br>- 단일 문자열 생성에는 과함   | 로그 생성, 텍스트 누적, 반복적 조작      |


## 🔍 간단 예시

### ✅ Span<char>
```csharp
ReadOnlySpan<char> span = "hello".AsSpan(0, 3); // "hel"
string result = span.ToString(); // 문자열로 변환
```

### ✅ StringBuilder
```csharp
var sb = new StringBuilder();
sb.Append("hel");
sb.Append("lo");
string result = sb.ToString(); // "hello"
```


## 🧠 실무 팁
- Span<char>는 GC 힙을 사용하지 않으면서도 안전하게 메모리 접근이 가능해, 실시간 시스템이나 파서 구현에 매우 유용합니다.
- StringBuilder는 반복적인 문자열 누적에 최적화되어 있어, 로그 생성이나 대량 텍스트 처리에 적합합니다.
- unsafe는 정말 필요한 경우에만! 대부분의 경우 Span<char>로 대체 가능합니다.



## 🧰 추천 방식: 포트란 입력 파일 생성 in C#
### 1. StringBuilder + string.Format 또는 보간 문자열
- 장점: 직관적이고 유지보수 쉬움
- 단점: 고정 폭 제어가 약간 불편할 수 있음
```csharp
var sb = new StringBuilder();
sb.AppendFormat("{0,-8}{1,-8}{2,16}{3,16}{4,-8}\n", "GRID*", "1", "1.27000e-01", "0.00000e+00", "*");
sb.AppendFormat("{0,-8}{1,16}\n", "*", "0.00000e+00");
```


### ✅ Tip: 보간 문자열 $"{val,-8}"도 사용 가능하지만, string.Format이 더 명시적이라 실수 줄이기 좋습니다.


### 2. Span<char> + stackalloc (고성능, 정밀 제어)
- 장점: GC 힙 사용 안 함, 메모리 복사 없음, 고정 폭 제어에 강력
- 단점: ref struct 제약, 문자열로 변환 시 ToString() 필요
```csharp
Span<char> buffer = stackalloc char[80];
"GRID*".AsSpan().CopyTo(buffer.Slice(0, 5));
"1".AsSpan().CopyTo(buffer.Slice(8, 1));
"1.27000e-01".AsSpan().CopyTo(buffer.Slice(16, 11));
"0.00000e+00".AsSpan().CopyTo(buffer.Slice(32, 11));
"*".AsSpan().CopyTo(buffer.Slice(48, 1));
string line = buffer.ToString(); // 포트란 스타일 고정 폭 문자열
```

#### ✅ Tip: stackalloc은 힙을 사용하지 않기 때문에 실시간 시스템이나 대량 생성 루프에 적합합니다.


### 3. TextWriter + 포맷 함수화
- 장점: 파일 출력과 포맷을 분리 가능, 테스트 용이
- 단점: 구조화 필요
```csharp
void WriteGrid(TextWriter writer, int id, double x, double y, double z)
{
    writer.WriteLine("{0,-8}{1,-8}{2,16:E5}{3,16:E5}{4,-8}", "GRID*", id, x, y, "*");
    writer.WriteLine("{0,-8}{1,16:E5}", "*", z);
}
```

#### ✅ Tip: 여러 카드 타입을 함수로 분리하면 유닛 테스트와 유지보수가 쉬워집니다.


### 🧠 포트란 입력 파일 생성: 실무 전략 요약

| 전략                         | 설명                                                                 |
|------------------------------|----------------------------------------------------------------------|
| 고정 폭 필드 함수화          | 카드별 포맷을 함수로 분리하면 실수 줄이고 재사용 가능               |
| 정렬 명시적 지정             | `{0,-8}`, `{1,16}` 등 폭과 방향을 명확히 지정해야 포트란이 인식함    |
| 파일 출력 분리               | 포맷 로직과 파일 저장을 분리하면 테스트와 디버깅이 쉬움              |
| Span<char>로 버퍼 제어       | 고성능이 필요한 경우 `Span<char>`로 직접 버퍼 조작 가능              |
| 카드별 템플릿화              | `GRID`, `CTRIA3`, `CQUAD4` 등 카드별로 템플릿을 만들어 관리           |
| 유닛 테스트 가능 구조화      | 각 카드 함수는 입력 → 문자열 반환 구조로 만들면 테스트가 쉬움        |


### 📁 예시 출력
GRID*   1                               1.27000e-01     0.00000e+00     *        
*       0.00000e+00    
CTRIA3  7298    1       3261    3554    3347


### 🧾 카드별 포맷 함수 (C#)
#### ✅ CQUAD4 카드
string FormatCQUAD4(int eid, int pid, int g1, int g2, int g3, int g4)
{
    return string.Format("{0,-8}{1,-8}{2,-8}{3,-8}{4,-8}{5,-8}",
        "CQUAD4", eid, pid, g1, g2, g3, g4);
}


#### ✅ CBUSH 카드
string FormatCBUSH(int eid, int pid, int g1, int g2)
{
    return string.Format("{0,-8}{1,-8}{2,-8}{3,-8}",
        "CBUSH", eid, pid, g1, g2);
}


#### ✅ FORCE 카드
string FormatFORCE(int sid, int g, int cid, double mag, double x, double y, double z)
{
    return string.Format("{0,-8}{1,-8}{2,-8}{3,-8}{4,16:E5}{5,16:E5}{6,16:E5}",
        "FORCE", sid, g, cid, mag, x, y, z);
}


### 📄 사용 예시
```csharp
Console.WriteLine(FormatCQUAD4(1001, 1, 2001, 2002, 2003, 2004));
Console.WriteLine(FormatCBUSH(3001, 2, 4001, 4002));
Console.WriteLine(FormatFORCE(5001, 6001, 0, 100.0, 1.0, 0.0, 0.0));
```

### 출력 예시:
```
CQUAD4  1001    1       2001    2002    2003    2004
CBUSH   3001    2       4001    4002
FORCE   5001    6001    0       1.00000E+02     1.00000E+00     0.00000E+00
```












